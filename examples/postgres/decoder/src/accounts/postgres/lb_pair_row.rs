//! This code was AUTOGENERATED using the Codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun Codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use carbon_core::account::AccountMetadata;
use carbon_core::postgres::metadata::AccountRowMetadata;
use carbon_core::postgres::primitives::Pubkey;
use carbon_core::postgres::primitives::U16;
use carbon_core::postgres::primitives::U64;
use carbon_core::postgres::primitives::U8;
use crate::accounts::LbPair;
use crate::types::ProtocolFee;
use crate::types::RewardInfo;
use crate::types::StaticParameters;
use crate::types::VariableParameters;


#[derive(sqlx::FromRow, Debug, Clone)]
pub struct LbPairRow {
    #[sqlx(flatten)]
        pub metadata: AccountRowMetadata,
            pub parameters: sqlx::types::Json<StaticParameters>,
        pub v_parameters: sqlx::types::Json<VariableParameters>,
        pub bump_seed: Vec<u8>,
        pub bin_step_seed: Vec<u8>,
        pub pair_type: U8,
        pub active_id: i32,
        pub bin_step: U16,
        pub status: U8,
        pub require_base_factor_seed: U8,
        pub base_factor_seed: Vec<u8>,
        pub activation_type: U8,
        pub creator_pool_on_off_control: U8,
        pub token_x_mint: Pubkey,
        pub token_y_mint: Pubkey,
        pub reserve_x: Pubkey,
        pub reserve_y: Pubkey,
        pub protocol_fee: sqlx::types::Json<ProtocolFee>,
        pub padding1: Vec<u8>,
        pub reward_infos: sqlx::types::Json<Vec<RewardInfo>>,
        pub oracle: Pubkey,
        pub bin_array_bitmap: Vec<U64>,
        pub last_updated_at: i64,
        pub padding2: Vec<u8>,
        pub pre_activation_swap_address: Pubkey,
        pub base_key: Pubkey,
        pub activation_point: U64,
        pub pre_activation_duration: U64,
        pub padding3: Vec<u8>,
        pub padding4: U64,
        pub creator: Pubkey,
        pub token_mint_x_program_flag: U8,
        pub token_mint_y_program_flag: U8,
        pub reserved: Vec<u8>,
}

impl LbPairRow {
    pub fn from_parts(source: LbPair, metadata: AccountMetadata) -> Self {
        Self {
            metadata: metadata.into(),
                        parameters: sqlx::types::Json(source.parameters.into()),
                        v_parameters: sqlx::types::Json(source.v_parameters.into()),
                        bump_seed: source.bump_seed.into(),
                        bin_step_seed: source.bin_step_seed.into(),
                        pair_type: source.pair_type.into(),
                        active_id: source.active_id.into(),
                        bin_step: source.bin_step.into(),
                        status: source.status.into(),
                        require_base_factor_seed: source.require_base_factor_seed.into(),
                        base_factor_seed: source.base_factor_seed.into(),
                        activation_type: source.activation_type.into(),
                        creator_pool_on_off_control: source.creator_pool_on_off_control.into(),
                        token_x_mint: source.token_x_mint.into(),
                        token_y_mint: source.token_y_mint.into(),
                        reserve_x: source.reserve_x.into(),
                        reserve_y: source.reserve_y.into(),
                        protocol_fee: sqlx::types::Json(source.protocol_fee.into()),
                        padding1: source.padding1.into(),
                        reward_infos: sqlx::types::Json(source.reward_infos.into_iter().map(|element| element.into()).collect()),
                        oracle: source.oracle.into(),
                        bin_array_bitmap: source.bin_array_bitmap.into_iter().map(|element| element.into()).collect(),
                        last_updated_at: source.last_updated_at.into(),
                        padding2: source.padding2.into(),
                        pre_activation_swap_address: source.pre_activation_swap_address.into(),
                        base_key: source.base_key.into(),
                        activation_point: source.activation_point.into(),
                        pre_activation_duration: source.pre_activation_duration.into(),
                        padding3: source.padding3.into(),
                        padding4: source.padding4.into(),
                        creator: source.creator.into(),
                        token_mint_x_program_flag: source.token_mint_x_program_flag.into(),
                        token_mint_y_program_flag: source.token_mint_y_program_flag.into(),
                        reserved: source.reserved.into(),
                    }
    }
}

impl TryFrom<LbPairRow> for LbPair {
    type Error = carbon_core::error::Error;
    fn try_from(source: LbPairRow) -> Result<Self, Self::Error> {
        Ok(Self {
                        parameters: source.parameters.0,
                        v_parameters: source.v_parameters.0,
                        bump_seed: source.bump_seed.into(),
                        bin_step_seed: source.bin_step_seed.into(),
                        pair_type: source.pair_type.try_into().map_err(|_| carbon_core::error::Error::Custom("Failed to convert value from postgres primitive".to_string()))?,
                        active_id: source.active_id.into(),
                        bin_step: source.bin_step.try_into().map_err(|_| carbon_core::error::Error::Custom("Failed to convert value from postgres primitive".to_string()))?,
                        status: source.status.try_into().map_err(|_| carbon_core::error::Error::Custom("Failed to convert value from postgres primitive".to_string()))?,
                        require_base_factor_seed: source.require_base_factor_seed.try_into().map_err(|_| carbon_core::error::Error::Custom("Failed to convert value from postgres primitive".to_string()))?,
                        base_factor_seed: source.base_factor_seed.into(),
                        activation_type: source.activation_type.try_into().map_err(|_| carbon_core::error::Error::Custom("Failed to convert value from postgres primitive".to_string()))?,
                        creator_pool_on_off_control: source.creator_pool_on_off_control.try_into().map_err(|_| carbon_core::error::Error::Custom("Failed to convert value from postgres primitive".to_string()))?,
                        token_x_mint: *source.token_x_mint,
                        token_y_mint: *source.token_y_mint,
                        reserve_x: *source.reserve_x,
                        reserve_y: *source.reserve_y,
                        protocol_fee: source.protocol_fee.0,
                        padding1: source.padding1.into(),
                        reward_infos: source.reward_infos.0.into_iter().collect::<Vec<_>>().try_into().map_err(|_| carbon_core::error::Error::Custom("Failed to convert value from postgres primitive".to_string()))?,
                        oracle: *source.oracle,
                        bin_array_bitmap: source.bin_array_bitmap.into_iter().map(|element| Ok(*element)).collect::<Result<Vec<_>, _>>()?.try_into().map_err(|_| carbon_core::error::Error::Custom("Failed to convert array element to primitive".to_string()))?,
                        last_updated_at: source.last_updated_at.into(),
                        padding2: source.padding2.into(),
                        pre_activation_swap_address: *source.pre_activation_swap_address,
                        base_key: *source.base_key,
                        activation_point: *source.activation_point,
                        pre_activation_duration: *source.pre_activation_duration,
                        padding3: source.padding3.into(),
                        padding4: *source.padding4,
                        creator: *source.creator,
                        token_mint_x_program_flag: source.token_mint_x_program_flag.try_into().map_err(|_| carbon_core::error::Error::Custom("Failed to convert value from postgres primitive".to_string()))?,
                        token_mint_y_program_flag: source.token_mint_y_program_flag.try_into().map_err(|_| carbon_core::error::Error::Custom("Failed to convert value from postgres primitive".to_string()))?,
                        reserved: source.reserved.into(),
                    })
    }
}

impl carbon_core::postgres::operations::Table for LbPair {
    fn table() -> &'static str {
        "lb_pair_account"
    }

    fn columns() -> Vec<&'static str> {
        vec![
                        "__pubkey",
            "__slot",
                                    "parameters",
                        "v_parameters",
                        "bump_seed",
                        "bin_step_seed",
                        "pair_type",
                        "active_id",
                        "bin_step",
                        "status",
                        "require_base_factor_seed",
                        "base_factor_seed",
                        "activation_type",
                        "creator_pool_on_off_control",
                        "token_x_mint",
                        "token_y_mint",
                        "reserve_x",
                        "reserve_y",
                        "protocol_fee",
                        "padding1",
                        "reward_infos",
                        "oracle",
                        "bin_array_bitmap",
                        "last_updated_at",
                        "padding2",
                        "pre_activation_swap_address",
                        "base_key",
                        "activation_point",
                        "pre_activation_duration",
                        "padding3",
                        "padding4",
                        "creator",
                        "token_mint_x_program_flag",
                        "token_mint_y_program_flag",
                        "reserved",
                    ]
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::Insert for LbPairRow {
    async fn insert(&self, pool: &sqlx::PgPool) -> carbon_core::error::CarbonResult<()> {
        sqlx::query(r#"
            INSERT INTO lb_pair_account (
                            "parameters",
                            "v_parameters",
                            "bump_seed",
                            "bin_step_seed",
                            "pair_type",
                            "active_id",
                            "bin_step",
                            "status",
                            "require_base_factor_seed",
                            "base_factor_seed",
                            "activation_type",
                            "creator_pool_on_off_control",
                            "token_x_mint",
                            "token_y_mint",
                            "reserve_x",
                            "reserve_y",
                            "protocol_fee",
                            "padding1",
                            "reward_infos",
                            "oracle",
                            "bin_array_bitmap",
                            "last_updated_at",
                            "padding2",
                            "pre_activation_swap_address",
                            "base_key",
                            "activation_point",
                            "pre_activation_duration",
                            "padding3",
                            "padding4",
                            "creator",
                            "token_mint_x_program_flag",
                            "token_mint_y_program_flag",
                            "reserved",
                                        __pubkey, __slot
                        ) VALUES (
                                                                            $1,                            $2,                            $3,                            $4,                            $5,                            $6,                            $7,                            $8,                            $9,                            $10,                            $11,                            $12,                            $13,                            $14,                            $15,                            $16,                            $17,                            $18,                            $19,                            $20,                            $21,                            $22,                            $23,                            $24,                            $25,                            $26,                            $27,                            $28,                            $29,                            $30,                            $31,                            $32,                            $33,                            $34,                            $35                    )"#)
                .bind(self.parameters.clone())
                .bind(self.v_parameters.clone())
                .bind(self.bump_seed.clone())
                .bind(self.bin_step_seed.clone())
                .bind(self.pair_type.clone())
                .bind(self.active_id.clone())
                .bind(self.bin_step.clone())
                .bind(self.status.clone())
                .bind(self.require_base_factor_seed.clone())
                .bind(self.base_factor_seed.clone())
                .bind(self.activation_type.clone())
                .bind(self.creator_pool_on_off_control.clone())
                .bind(self.token_x_mint.clone())
                .bind(self.token_y_mint.clone())
                .bind(self.reserve_x.clone())
                .bind(self.reserve_y.clone())
                .bind(self.protocol_fee.clone())
                .bind(self.padding1.clone())
                .bind(self.reward_infos.clone())
                .bind(self.oracle.clone())
                .bind(self.bin_array_bitmap.clone())
                .bind(self.last_updated_at.clone())
                .bind(self.padding2.clone())
                .bind(self.pre_activation_swap_address.clone())
                .bind(self.base_key.clone())
                .bind(self.activation_point.clone())
                .bind(self.pre_activation_duration.clone())
                .bind(self.padding3.clone())
                .bind(self.padding4.clone())
                .bind(self.creator.clone())
                .bind(self.token_mint_x_program_flag.clone())
                .bind(self.token_mint_y_program_flag.clone())
                .bind(self.reserved.clone())
                        .bind(self.metadata.pubkey.clone())
        .bind(self.metadata.slot.clone())
                .execute(pool).await
        .map_err(|e| carbon_core::error::Error::Custom(e.to_string()))?;
        Ok(())
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::Upsert for LbPairRow {
    async fn upsert(&self, pool: &sqlx::PgPool) -> carbon_core::error::CarbonResult<()> {
        sqlx::query(r#"INSERT INTO lb_pair_account (
                        "parameters",
                        "v_parameters",
                        "bump_seed",
                        "bin_step_seed",
                        "pair_type",
                        "active_id",
                        "bin_step",
                        "status",
                        "require_base_factor_seed",
                        "base_factor_seed",
                        "activation_type",
                        "creator_pool_on_off_control",
                        "token_x_mint",
                        "token_y_mint",
                        "reserve_x",
                        "reserve_y",
                        "protocol_fee",
                        "padding1",
                        "reward_infos",
                        "oracle",
                        "bin_array_bitmap",
                        "last_updated_at",
                        "padding2",
                        "pre_activation_swap_address",
                        "base_key",
                        "activation_point",
                        "pre_activation_duration",
                        "padding3",
                        "padding4",
                        "creator",
                        "token_mint_x_program_flag",
                        "token_mint_y_program_flag",
                        "reserved",
                                    __pubkey, __slot
                    ) VALUES (
                                                                        $1,                        $2,                        $3,                        $4,                        $5,                        $6,                        $7,                        $8,                        $9,                        $10,                        $11,                        $12,                        $13,                        $14,                        $15,                        $16,                        $17,                        $18,                        $19,                        $20,                        $21,                        $22,                        $23,                        $24,                        $25,                        $26,                        $27,                        $28,                        $29,                        $30,                        $31,                        $32,                        $33,                        $34,                        $35                    ) ON CONFLICT (
                        __pubkey
                    ) DO UPDATE SET
                        "parameters" = EXCLUDED."parameters",
                        "v_parameters" = EXCLUDED."v_parameters",
                        "bump_seed" = EXCLUDED."bump_seed",
                        "bin_step_seed" = EXCLUDED."bin_step_seed",
                        "pair_type" = EXCLUDED."pair_type",
                        "active_id" = EXCLUDED."active_id",
                        "bin_step" = EXCLUDED."bin_step",
                        "status" = EXCLUDED."status",
                        "require_base_factor_seed" = EXCLUDED."require_base_factor_seed",
                        "base_factor_seed" = EXCLUDED."base_factor_seed",
                        "activation_type" = EXCLUDED."activation_type",
                        "creator_pool_on_off_control" = EXCLUDED."creator_pool_on_off_control",
                        "token_x_mint" = EXCLUDED."token_x_mint",
                        "token_y_mint" = EXCLUDED."token_y_mint",
                        "reserve_x" = EXCLUDED."reserve_x",
                        "reserve_y" = EXCLUDED."reserve_y",
                        "protocol_fee" = EXCLUDED."protocol_fee",
                        "padding1" = EXCLUDED."padding1",
                        "reward_infos" = EXCLUDED."reward_infos",
                        "oracle" = EXCLUDED."oracle",
                        "bin_array_bitmap" = EXCLUDED."bin_array_bitmap",
                        "last_updated_at" = EXCLUDED."last_updated_at",
                        "padding2" = EXCLUDED."padding2",
                        "pre_activation_swap_address" = EXCLUDED."pre_activation_swap_address",
                        "base_key" = EXCLUDED."base_key",
                        "activation_point" = EXCLUDED."activation_point",
                        "pre_activation_duration" = EXCLUDED."pre_activation_duration",
                        "padding3" = EXCLUDED."padding3",
                        "padding4" = EXCLUDED."padding4",
                        "creator" = EXCLUDED."creator",
                        "token_mint_x_program_flag" = EXCLUDED."token_mint_x_program_flag",
                        "token_mint_y_program_flag" = EXCLUDED."token_mint_y_program_flag",
                        "reserved" = EXCLUDED."reserved",
                                    __slot = EXCLUDED.__slot
                    "#)
                .bind(self.parameters.clone())
                .bind(self.v_parameters.clone())
                .bind(self.bump_seed.clone())
                .bind(self.bin_step_seed.clone())
                .bind(self.pair_type.clone())
                .bind(self.active_id.clone())
                .bind(self.bin_step.clone())
                .bind(self.status.clone())
                .bind(self.require_base_factor_seed.clone())
                .bind(self.base_factor_seed.clone())
                .bind(self.activation_type.clone())
                .bind(self.creator_pool_on_off_control.clone())
                .bind(self.token_x_mint.clone())
                .bind(self.token_y_mint.clone())
                .bind(self.reserve_x.clone())
                .bind(self.reserve_y.clone())
                .bind(self.protocol_fee.clone())
                .bind(self.padding1.clone())
                .bind(self.reward_infos.clone())
                .bind(self.oracle.clone())
                .bind(self.bin_array_bitmap.clone())
                .bind(self.last_updated_at.clone())
                .bind(self.padding2.clone())
                .bind(self.pre_activation_swap_address.clone())
                .bind(self.base_key.clone())
                .bind(self.activation_point.clone())
                .bind(self.pre_activation_duration.clone())
                .bind(self.padding3.clone())
                .bind(self.padding4.clone())
                .bind(self.creator.clone())
                .bind(self.token_mint_x_program_flag.clone())
                .bind(self.token_mint_y_program_flag.clone())
                .bind(self.reserved.clone())
                        .bind(self.metadata.pubkey)
        .bind(self.metadata.slot.clone())
                .execute(pool).await
        .map_err(|e| carbon_core::error::Error::Custom(e.to_string()))?;

        Ok(())
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::Delete for LbPairRow {
    type Key = carbon_core::postgres::primitives::Pubkey;

    async fn delete(key: Self::Key, pool: &sqlx::PgPool) -> carbon_core::error::CarbonResult<()> {
        sqlx::query(r#"DELETE FROM lb_pair_account WHERE
                        __pubkey = $1
                    "#)
                .bind(key)
                .execute(pool).await
        .map_err(|e| carbon_core::error::Error::Custom(e.to_string()))?;

        Ok(())
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::LookUp for LbPairRow {
    type Key = carbon_core::postgres::primitives::Pubkey;

    async fn lookup(key: Self::Key, pool: &sqlx::PgPool) -> carbon_core::error::CarbonResult<Option<Self>> {
        let row = sqlx::query_as(r#"SELECT * FROM lb_pair_account WHERE
                        __pubkey = $1
                    "#)
                .bind(key)
                .fetch_optional(pool).await
        .map_err(|e| carbon_core::error::Error::Custom(e.to_string()))
        ?;

        Ok(row)
    }
}

pub struct LbPairMigrationOperation;

#[async_trait::async_trait]
impl sqlx_migrator::Operation<sqlx::Postgres> for LbPairMigrationOperation {
    async fn up(&self, connection: &mut sqlx::PgConnection) -> Result<(), sqlx_migrator::error::Error> {
        sqlx::query(r#"CREATE TABLE IF NOT EXISTS lb_pair_account (
                        -- Account data
                                    "parameters" JSONB NOT NULL,
                        "v_parameters" JSONB NOT NULL,
                        "bump_seed" BYTEA NOT NULL,
                        "bin_step_seed" BYTEA NOT NULL,
                        "pair_type" INT2 NOT NULL,
                        "active_id" INT4 NOT NULL,
                        "bin_step" INT4 NOT NULL,
                        "status" INT2 NOT NULL,
                        "require_base_factor_seed" INT2 NOT NULL,
                        "base_factor_seed" BYTEA NOT NULL,
                        "activation_type" INT2 NOT NULL,
                        "creator_pool_on_off_control" INT2 NOT NULL,
                        "token_x_mint" BYTEA NOT NULL,
                        "token_y_mint" BYTEA NOT NULL,
                        "reserve_x" BYTEA NOT NULL,
                        "reserve_y" BYTEA NOT NULL,
                        "protocol_fee" JSONB NOT NULL,
                        "padding1" BYTEA NOT NULL,
                        "reward_infos" JSONB NOT NULL,
                        "oracle" BYTEA NOT NULL,
                        "bin_array_bitmap" NUMERIC(20)[] NOT NULL,
                        "last_updated_at" INT8 NOT NULL,
                        "padding2" BYTEA NOT NULL,
                        "pre_activation_swap_address" BYTEA NOT NULL,
                        "base_key" BYTEA NOT NULL,
                        "activation_point" NUMERIC(20) NOT NULL,
                        "pre_activation_duration" NUMERIC(20) NOT NULL,
                        "padding3" BYTEA NOT NULL,
                        "padding4" NUMERIC(20) NOT NULL,
                        "creator" BYTEA NOT NULL,
                        "token_mint_x_program_flag" INT2 NOT NULL,
                        "token_mint_y_program_flag" INT2 NOT NULL,
                        "reserved" BYTEA NOT NULL,
            
                        -- Account metadata
            __pubkey BYTEA NOT NULL,
            __slot NUMERIC(20),
            
                        PRIMARY KEY (__pubkey)
                    )"#).execute(connection).await?;
        Ok(())
    }

    async fn down(&self, connection: &mut sqlx::PgConnection) -> Result<(), sqlx_migrator::error::Error> {
        sqlx::query(r#"DROP TABLE IF EXISTS lb_pair_account"#).execute(connection).await?;
        Ok(())
    }
}

