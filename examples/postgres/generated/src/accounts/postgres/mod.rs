//! This code was AUTOGENERATED using the Codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun Codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

pub mod amm_config_row;
pub mod observation_state_row;
pub mod operation_state_row;
pub mod personal_position_state_row;
pub mod pool_state_row;
pub mod protocol_position_state_row;
pub mod tick_array_bitmap_extension_row;
pub mod tick_array_state_row;

pub use self::amm_config_row::*;
pub use self::observation_state_row::*;
pub use self::operation_state_row::*;
pub use self::personal_position_state_row::*;
pub use self::pool_state_row::*;
pub use self::protocol_position_state_row::*;
pub use self::tick_array_bitmap_extension_row::*;
pub use self::tick_array_state_row::*;

use super::AmmV3Account;

pub struct AmmV3AccountsMigration;

impl sqlx_migrator::Migration<sqlx::Postgres> for AmmV3AccountsMigration {
    fn app(&self) -> &str {
        "amm-v3"
    }

    fn name(&self) -> &str {
        "amm_v3_accounts"
    }

    fn operations(&self) -> Vec<Box<dyn sqlx_migrator::Operation<sqlx::Postgres>>> {
        vec![
                        Box::new(AmmConfigMigrationOperation),
                        Box::new(ObservationStateMigrationOperation),
                        Box::new(OperationStateMigrationOperation),
                        Box::new(PersonalPositionStateMigrationOperation),
                        Box::new(PoolStateMigrationOperation),
                        Box::new(ProtocolPositionStateMigrationOperation),
                        Box::new(TickArrayBitmapExtensionMigrationOperation),
                        Box::new(TickArrayStateMigrationOperation),
                    ]
    }

    fn parents(&self) -> Vec<Box<dyn sqlx_migrator::Migration<sqlx::Postgres>>> {
        vec![]
    }
}

pub struct AmmV3AccountWithMetadata(pub AmmV3Account, pub carbon_core::account::AccountMetadata);

impl From<(AmmV3Account, carbon_core::account::AccountMetadata)> for AmmV3AccountWithMetadata {
    fn from(value: (AmmV3Account, carbon_core::account::AccountMetadata)) -> Self {
        AmmV3AccountWithMetadata(value.0, value.1)
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::Insert for AmmV3AccountWithMetadata {
    async fn insert(&self, pool: &sqlx::PgPool) -> carbon_core::error::CarbonResult<()> {
        let AmmV3AccountWithMetadata(account, metadata) = self;

        match account {
                        AmmV3Account::AmmConfig(account) => {
                let row = amm_config_row::AmmConfigRow::from_parts(account.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
                        AmmV3Account::OperationState(account) => {
                let row = operation_state_row::OperationStateRow::from_parts(account.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
                        AmmV3Account::ObservationState(account) => {
                let row = observation_state_row::ObservationStateRow::from_parts(account.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
                        AmmV3Account::PersonalPositionState(account) => {
                let row = personal_position_state_row::PersonalPositionStateRow::from_parts(account.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
                        AmmV3Account::PoolState(account) => {
                let row = pool_state_row::PoolStateRow::from_parts(account.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
                        AmmV3Account::ProtocolPositionState(account) => {
                let row = protocol_position_state_row::ProtocolPositionStateRow::from_parts(account.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
                        AmmV3Account::TickArrayState(account) => {
                let row = tick_array_state_row::TickArrayStateRow::from_parts(account.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
                        AmmV3Account::TickArrayBitmapExtension(account) => {
                let row = tick_array_bitmap_extension_row::TickArrayBitmapExtensionRow::from_parts(account.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
                    }
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::Upsert for AmmV3AccountWithMetadata {
    async fn upsert(&self, pool: &sqlx::PgPool) -> carbon_core::error::CarbonResult<()> {
        let AmmV3AccountWithMetadata(account, metadata) = self;
        match account {
                        AmmV3Account::AmmConfig(account) => {
                let row = amm_config_row::AmmConfigRow::from_parts(account.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
                        AmmV3Account::OperationState(account) => {
                let row = operation_state_row::OperationStateRow::from_parts(account.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
                        AmmV3Account::ObservationState(account) => {
                let row = observation_state_row::ObservationStateRow::from_parts(account.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
                        AmmV3Account::PersonalPositionState(account) => {
                let row = personal_position_state_row::PersonalPositionStateRow::from_parts(account.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
                        AmmV3Account::PoolState(account) => {
                let row = pool_state_row::PoolStateRow::from_parts(account.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
                        AmmV3Account::ProtocolPositionState(account) => {
                let row = protocol_position_state_row::ProtocolPositionStateRow::from_parts(account.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
                        AmmV3Account::TickArrayState(account) => {
                let row = tick_array_state_row::TickArrayStateRow::from_parts(account.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
                        AmmV3Account::TickArrayBitmapExtension(account) => {
                let row = tick_array_bitmap_extension_row::TickArrayBitmapExtensionRow::from_parts(account.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
                    }
    }
}

