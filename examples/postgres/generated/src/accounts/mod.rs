//! This code was AUTOGENERATED using the Codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun Codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use crate::{PROGRAM_ID, AmmV3Decoder};

#[cfg(feature = "postgres")]
pub mod postgres;

#[cfg(feature = "graphql")]
pub mod graphql;

pub mod amm_config;
pub mod observation_state;
pub mod operation_state;
pub mod personal_position_state;
pub mod pool_state;
pub mod protocol_position_state;
pub mod tick_array_bitmap_extension;
pub mod tick_array_state;

pub use self::amm_config::*;
pub use self::observation_state::*;
pub use self::operation_state::*;
pub use self::personal_position_state::*;
pub use self::pool_state::*;
pub use self::protocol_position_state::*;
pub use self::tick_array_bitmap_extension::*;
pub use self::tick_array_state::*;

#[derive(Debug, Clone, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[cfg_attr(feature = "serde", serde(tag = "type", content = "data"))]
pub enum AmmV3Account {
    AmmConfig(AmmConfig),
    ObservationState(ObservationState),
    OperationState(OperationState),
    PersonalPositionState(PersonalPositionState),
    PoolState(PoolState),
    ProtocolPositionState(ProtocolPositionState),
    TickArrayBitmapExtension(TickArrayBitmapExtension),
    TickArrayState(TickArrayState),
}

impl<'a> carbon_core::account::AccountDecoder<'a> for AmmV3Decoder {
    type AccountType = AmmV3Account;
    
    fn decode_account(
        &self,
        account: &'a solana_account::Account,
    ) -> Option<carbon_core::account::DecodedAccount<Self::AccountType>> {
        if account.owner != PROGRAM_ID {
            return None;
        }
        
        let data = account.data.as_slice();
        
                // Try to decode AmmConfig
        {
            if let Some(decoded) = amm_config::AmmConfig::decode(data) {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: AmmV3Account::AmmConfig(decoded),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }
                // Try to decode OperationState
        {
            if let Some(decoded) = operation_state::OperationState::decode(data) {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: AmmV3Account::OperationState(decoded),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }
                // Try to decode ObservationState
        {
            if let Some(decoded) = observation_state::ObservationState::decode(data) {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: AmmV3Account::ObservationState(decoded),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }
                // Try to decode PersonalPositionState
        {
            if let Some(decoded) = personal_position_state::PersonalPositionState::decode(data) {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: AmmV3Account::PersonalPositionState(decoded),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }
                // Try to decode PoolState
        {
            if let Some(decoded) = pool_state::PoolState::decode(data) {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: AmmV3Account::PoolState(decoded),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }
                // Try to decode ProtocolPositionState
        {
            if let Some(decoded) = protocol_position_state::ProtocolPositionState::decode(data) {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: AmmV3Account::ProtocolPositionState(decoded),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }
                // Try to decode TickArrayState
        {
            if let Some(decoded) = tick_array_state::TickArrayState::decode(data) {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: AmmV3Account::TickArrayState(decoded),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }
                // Try to decode TickArrayBitmapExtension
        {
            if let Some(decoded) = tick_array_bitmap_extension::TickArrayBitmapExtension::decode(data) {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: AmmV3Account::TickArrayBitmapExtension(decoded),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }
                
        None
    }
}

