use juniper::{graphql_object, FieldResult};
use std::str::FromStr;
{% import "macros.njk" as macros %}

pub struct QueryRoot;

#[graphql_object(context = crate::graphql::context::GraphQLContext)]
impl QueryRoot {
    // Accounts
    {% for account in accountsToExport %}
    {% if account.data.kind == 'structTypeNode' and account.data.fields.length > 0 %}
    async fn {{ macros.escapeRustKeyword(account.name | snakeCase) }}(
        context: &crate::graphql::context::GraphQLContext,
        pubkey: String,
    ) -> FieldResult<Option<crate::accounts::graphql::{{ account.name | pascalCase }}GraphQL>> {
        use carbon_core::postgres::operations::LookUp;
        use carbon_core::postgres::primitives::Pubkey as PgPubkey;
        let pk = PgPubkey(solana_pubkey::Pubkey::from_str(&pubkey).map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?);
        let row = crate::accounts::postgres::{{ account.name | pascalCase }}Row::lookup(pk, &context.pool).await
            .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(row.map(|row| row.try_into().ok()).flatten())
    }

    async fn list_{{ macros.escapeRustKeyword(account.name | snakeCase) }}(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::accounts::graphql::{{ account.name | pascalCase }}GraphQL>> {
        let rows: Vec<crate::accounts::postgres::{{ account.name | pascalCase }}Row> = sqlx::query_as(
            r#"SELECT * FROM {{ account.name | snakeCase }}_account ORDER BY __slot DESC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }
    {% endif %}
    {% endfor %}

    // Instructions (per-instruction list and lookup by signature+index)
    {% for instruction in instructionsToExport %}
    {% if instruction.arguments.length > 1 %}
    async fn {{ macros.escapeRustKeyword(instruction.name | snakeCase) }}(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::{{ instruction.name | pascalCase }}GraphQL>> {
        let rows: Vec<crate::instructions::postgres::{{ instruction.name | pascalCase }}Row> = sqlx::query_as(
            r#"SELECT * FROM {{ instruction.name | snakeCase }}_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }

    async fn list_{{ instruction.name | snakeCase }}(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::{{ instruction.name | pascalCase }}GraphQL>> {
        let rows: Vec<crate::instructions::postgres::{{ instruction.name | pascalCase }}Row> = sqlx::query_as(
            r#"SELECT * FROM {{ instruction.name | snakeCase }}_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }
    {% endif %}
    {% endfor %}

    {% if hasAnchorEvents %}
    async fn list_cpi_events(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::CpiEventGraphQL>> {
        let rows: Vec<crate::instructions::postgres::CpiEventRow> = sqlx::query_as(
            r#"SELECT * FROM cpi_events ORDER BY __slot DESC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows.into_iter().filter_map(|row| row.try_into().ok()).collect())
    }
    {% endif %}
}

