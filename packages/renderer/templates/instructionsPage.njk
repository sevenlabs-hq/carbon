{% extends "layout.njk" %}
{% import "macros.njk" as macros %}

{% block main %}
{{ imports }}

{% if instruction.docs and instruction.docs.length > 0 %}
{{ macros.docblock(instruction.docs) }}
{% endif %}
{{ macros.coreDecoderDerives() }}
pub struct {{ instruction.name | pascalCase }} {
{% for arg in instruction.arguments -%}
  {% if arg.docs %}{% for doc in arg.docs %}{% set lines = doc.split('\n') %}{% for line in lines %}    /// {{ line }}
{% endfor %}{% endfor %}{% endif %}
  {% if argumentTypes[loop.index0].requiredBigArray %}  #[cfg_attr(feature = "serde", serde(with = "serde_big_array::BigArray"))]
  {% endif %}
  pub {{ arg.name | snakeCase }}: {{ argumentTypes[loop.index0].type }},
{% endfor -%}
}

{{ macros.simpleStructDerives() }}
pub struct {{ instruction.name | pascalCase }}InstructionAccounts {
{% for account in instruction.accounts %}
    pub {{ macros.escapeRustKeyword(account.name | snakeCase) }}: {% if account.isOptional %}Option<solana_pubkey::Pubkey>{% else %}solana_pubkey::Pubkey{% endif %},
{% endfor %}
{% if instruction.accounts | length > 0 %}
    pub remaining: Vec<solana_instruction::AccountMeta>,
{% endif %}
}

impl {{ instruction.name | pascalCase }} {
    pub fn decode(data: &[u8]) -> Option<Self> {
{% if discriminatorManifest -%}
{{ discriminatorManifest.checkCode | safe }}
{% endif %}

        let mut data_slice = data;

{% if discriminatorManifest %}
        data_slice = &data_slice[{{ discriminatorManifest.size }}..];
{% endif %}

        borsh::BorshDeserialize::deserialize(&mut data_slice).ok()
    }
}

impl ArrangeAccounts for {{ instruction.name | pascalCase }} {
    type ArrangedAccounts = {{ instruction.name | pascalCase }}InstructionAccounts;

    fn arrange_accounts(
        {% if instruction.accounts | length > 0 %}accounts{% else %}_accounts{% endif %}: &[solana_instruction::AccountMeta],
    ) -> Option<Self::ArrangedAccounts> {
{% if instruction.accounts | length > 0 %}
        let mut iter = accounts.iter();

{% for account in instruction.accounts %}
        let {{ macros.escapeRustKeyword(account.name | snakeCase) }} = next_account(&mut iter){% if not account.isOptional %}?{% endif %};
{% endfor %}

        let remaining = iter.as_slice();

        Some({{ instruction.name | pascalCase }}InstructionAccounts {
{% for account in instruction.accounts %}
            {{ macros.escapeRustKeyword(account.name | snakeCase) }},
{% endfor %}
            remaining: remaining.to_vec(),
        })
{% else %}
        Some({{ instruction.name | pascalCase }}InstructionAccounts {})
{% endif %}
    }
}
{% endblock %}