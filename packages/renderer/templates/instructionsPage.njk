{% extends "layout.njk" %}
{% import "macros.njk" as macros %}

{% block main %}

{{ imports }}

{{ macros.docblock(instruction.docs) }}
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[derive(Debug, Clone, carbon_core::borsh::BorshSerialize, carbon_core::borsh::BorshDeserialize, PartialEq)]
pub struct {{ instruction.name | pascalCase }} {
{% for arg in instruction.arguments %}
    {% if arg.docs %}{{ macros.docblock(arg.docs) }}{% endif %}
    pub {{ arg.name | snakeCase }}: {{ argumentTypes[loop.index0].type }},
{% endfor %}
}

#[derive(Debug, Clone, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct {{ instruction.name | pascalCase }}InstructionAccounts {
{% set seenFields = [] %}
{% for account in instruction.accounts %}
    {% set fieldName = account.name | snakeCase %}
    {% if not (fieldName in seenFields) %}
    pub {{ fieldName }}: {% if account.isOptional %}Option<solana_pubkey::Pubkey>{% else %}solana_pubkey::Pubkey{% endif %},
    {% set _ = seenFields.push(fieldName) %}
    {% endif %}
{% endfor %}
{% if instruction.accounts | length > 0 %}
    pub remaining: Vec<solana_instruction::AccountMeta>,
{% endif %}
}

impl {{ instruction.name | pascalCase }} {
    pub fn decode(data: &[u8]) -> Option<Self> {
        {% if discriminatorManifest %}
        {{ discriminatorManifest.checkCode | safe }}
        {% endif %}

        let mut data_slice = data;

        {% if discriminatorManifest %}
        data_slice = &data_slice[{{ discriminatorManifest.size }}..];
        {% endif %}

        if let Ok(decoded) = Self::deserialize(&mut data_slice) {
            return Some(decoded);
        }

        None
    }
}

impl ArrangeAccounts for {{ instruction.name | pascalCase }} {
    type ArrangedAccounts = {{ instruction.name | pascalCase }}InstructionAccounts;

    fn arrange_accounts(
        accounts: &[solana_instruction::AccountMeta],
    ) -> Option<Self::ArrangedAccounts> {
        {% if instruction.accounts | length > 0 %}
        let mut iter = accounts.iter();

        {% set seenFields = [] %}
        {% for account in instruction.accounts %}
            {% set fieldName = account.name | snakeCase %}
            {% if not (fieldName in seenFields) %}
        let {{ fieldName }} = next_account(&mut iter){% if not account.isOptional %}?{% endif %};
            {% set _ = seenFields.push(fieldName) %}
            {% endif %}
        {% endfor %}

        let remaining = iter.as_slice();

        Some({{ instruction.name | pascalCase }}InstructionAccounts {
            {% set seenFields = [] %}
            {% for account in instruction.accounts %}
                {% set fieldName = account.name | snakeCase %}
                {% if not (fieldName in seenFields) %}
            {{ fieldName }}: {{ fieldName }},
                {% set _ = seenFields.push(fieldName) %}
                {% endif %}
            {% endfor %}
            remaining: remaining.to_vec(),
        })
        {% else %}
        Some({{ instruction.name | pascalCase }}InstructionAccounts {})
        {% endif %}
    }
}

{% endblock %}