{% extends "layout.njk" %}

{% block main %}

#[cfg(feature = "postgres")]
pub mod postgres;

use crate::{PROGRAM_ID, {{ program.name | pascalCase }}Decoder};

{% for instruction in instructionsToExport | sort(false, false, 'name') %}
pub mod {{ instruction.name | snakeCase }};
{% endfor %}

{% for instruction in instructionsToExport | sort(false, false, 'name') %}
pub use self::{{ instruction.name | snakeCase }}::*;
{% endfor %}

#[derive(Debug, Clone, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[cfg_attr(feature = "serde", serde(tag = "type", content = "data"))]
pub enum {{ program.name | pascalCase }}Instruction {
{% for instruction in instructionsToExport | sort(false, false, 'name') %}
    {{ instruction.name | pascalCase }}({{ instruction.name | pascalCase }}),
{% endfor %}
}

impl carbon_core::instruction::InstructionDecoder<'_> for {{ program.name | pascalCase }}Decoder {
    type InstructionType = {{ program.name | pascalCase }}Instruction;

    fn decode_instruction(
        &self,
        instruction: &solana_instruction::Instruction,
    ) -> Option<carbon_core::instruction::DecodedInstruction<Self::InstructionType>> {
        if !instruction.program_id.eq(&PROGRAM_ID) {
            return None;
        }

        let data = instruction.data.as_slice();
        
        {% for instruction in instructionsToExport %}
        // Try to decode {{ instruction.name | pascalCase }}
        {
            if let Some(decoded) = {{ instruction.name | snakeCase }}::{{ instruction.name | pascalCase }}::decode(data) {
                return Some(carbon_core::instruction::DecodedInstruction {
                    program_id: instruction.program_id,
                    data: {{ program.name | pascalCase }}Instruction::{{ instruction.name | pascalCase }}(decoded),
                    accounts: instruction.accounts.clone(),
                });
            }
        }
        {% endfor %}
        
        None
    }
}

{% endblock %}