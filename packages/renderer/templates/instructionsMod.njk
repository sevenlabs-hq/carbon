{% extends "layout.njk" %}
{% import "macros.njk" as macros %}

{% block main %}
{{ imports }}
{% if withPostgres and postgresMode !== 'generic' %}
#[cfg(feature = "postgres")]
pub mod postgres;
{% endif %}

{% if withGraphQL %}
#[cfg(feature = "graphql")]
pub mod graphql;
{% endif %}

{% for instruction in instructionsToExport | sort(false, false, 'name') %}
pub mod {{ macros.escapeRustKeyword(instruction.name | snakeCase) }};
{% endfor %}
{% if hasAnchorEvents %}
pub mod cpi_event;
{% endif %}

{% for instruction in instructionsToExport | sort(false, false, 'name') %}
pub use self::{{ macros.escapeRustKeyword(instruction.name | snakeCase) }}::*;
{% endfor %}
{% if hasAnchorEvents %}
pub use self::cpi_event::*;
{% endif %}

{{ macros.enumWrapperDerives() }}
pub enum {{ program.name | pascalCase }}Instruction {
{% for instruction in instructionsToExport | sort(false, false, 'name') %}
    {{ instruction.name | pascalCase }}({{ instruction.name | pascalCase }}),
{% endfor %}
{% if hasAnchorEvents %}
    // Anchor CPI Event Instruction
    CpiEvent(CpiEvent)
{% endif %}
}

impl carbon_core::instruction::InstructionDecoder<'_> for {{ program.name | pascalCase }}Decoder {
    type InstructionType = {{ program.name | pascalCase }}Instruction;

    fn decode_instruction(
        &self,
        instruction: &solana_instruction::Instruction,
    ) -> Option<carbon_core::instruction::DecodedInstruction<Self::InstructionType>> {
        if !instruction.program_id.eq(&PROGRAM_ID) {
            return None;
        }

        let data = instruction.data.as_slice();

{% for instruction in instructionsToExport %}
        {
            if let Some(decoded) = {{ macros.escapeRustKeyword(instruction.name | snakeCase) }}::{{ instruction.name | pascalCase }}::decode(data) {
                return Some(carbon_core::instruction::DecodedInstruction {
                    program_id: instruction.program_id,
                    data: {{ program.name | pascalCase }}Instruction::{{ instruction.name | pascalCase }}(decoded),
                    accounts: instruction.accounts.clone(),
                });
            }
        }
{% endfor %}
{% if hasAnchorEvents %}
        {
            if let Some(decoded) = cpi_event::CpiEvent::decode(data) {
                return Some(carbon_core::instruction::DecodedInstruction {
                    program_id: instruction.program_id,
                    data: {{ program.name | pascalCase }}Instruction::CpiEvent(decoded),
                    accounts: instruction.accounts.clone(),
                });
            }
        }
{% endif %}

        None
    }
}
{% endblock %}