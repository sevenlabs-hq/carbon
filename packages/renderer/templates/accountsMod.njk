{% extends "layout.njk" %}
{% import "macros.njk" as macros %}

{% block main %}
{{ imports }}

{% if withPostgres and postgresMode !== 'generic' %}
#[cfg(feature = "postgres")]
pub mod postgres;
{% endif %}

{% if withGraphQL %}
#[cfg(feature = "graphql")]
pub mod graphql;
{% endif %}

{% for account in accountsToExport | sort(false, false, 'name') %}
pub mod {{ macros.escapeRustKeyword(account.name | snakeCase) }};
{% endfor %}

{{ macros.enumWrapperDerives() }}
pub enum {{ program.name | pascalCase }}Account {
{% for account in accountsToExport | sort(false, false, 'name') %}
    {{ account.name | pascalCase }}(Box<{{ account.name | snakeCase }}::{{ account.name | pascalCase }}>),
{% endfor %}
}

impl<'a> carbon_core::account::AccountDecoder<'a> for {{ program.name | pascalCase }}Decoder {
    type AccountType = {{ program.name | pascalCase }}Account;

    fn decode_account(
        &self,
        account: &'a solana_account::Account,
    ) -> Option<carbon_core::account::DecodedAccount<Self::AccountType>> {
        if account.owner != PROGRAM_ID {
            return None;
        }

{% if originalProgramName === 'token-2022' %}
        {% for account in accountsToExport %}
        {% if account.name | lower === 'mint' %}
        // Try Mint (base or with extensions) - StateWithExtensions::unpack handles both
        if let Ok(data) = spl_token_2022::extension::StateWithExtensions::<spl_token_2022::state::Mint>::unpack(&account.data) {
            return Some(carbon_core::account::DecodedAccount {
                lamports: account.lamports,
                data: {{ program.name | pascalCase }}Account::{{ account.name | pascalCase }}(Box::new({{ macros.escapeRustKeyword(account.name | snakeCase) }}::{{ account.name | pascalCase }}::from(data))),
                owner: account.owner,
                executable: account.executable,
                rent_epoch: account.rent_epoch,
            });
        }
        {% elif account.name | lower === 'token' %}
        // Try Token Account (base or with extensions)
        if let Ok(data) = spl_token_2022::extension::StateWithExtensions::<spl_token_2022::state::Account>::unpack(&account.data) {
            return Some(carbon_core::account::DecodedAccount {
                lamports: account.lamports,
                data: {{ program.name | pascalCase }}Account::{{ account.name | pascalCase }}(Box::new({{ macros.escapeRustKeyword(account.name | snakeCase) }}::{{ account.name | pascalCase }}::from(data))),
                owner: account.owner,
                executable: account.executable,
                rent_epoch: account.rent_epoch,
            });
        }
        {% elif account.name | lower === 'multisig' %}
        // Try Multisig (no extensions support)
        if let Ok(data) = spl_token_2022::state::Multisig::unpack_unchecked(&account.data) {
            return Some(carbon_core::account::DecodedAccount {
                lamports: account.lamports,
                data: {{ program.name | pascalCase }}Account::{{ account.name | pascalCase }}(Box::new({{ macros.escapeRustKeyword(account.name | snakeCase) }}::{{ account.name | pascalCase }}::from(data))),
                owner: account.owner,
                executable: account.executable,
                rent_epoch: account.rent_epoch,
            });
        }
        {% endif %}
        {% endfor %}
{% else %}
{% if accountsToExport.length == 0 %}
        let _data = account.data.as_slice();
{% else %}
        let data = account.data.as_slice();
{% endif %}

{% for account in accountsToExport %}
        {
            if let Some(decoded) = {{ macros.escapeRustKeyword(account.name | snakeCase) }}::{{ account.name | pascalCase }}::decode(data) {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: {{ program.name | pascalCase }}Account::{{ account.name | pascalCase }}(Box::new(decoded)),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }
{% endfor %}
{% endif %}

        None
    }
}

{% if originalProgramName === 'token-2022' %}
#[cfg(test)]
mod tests {
    use {super::*, carbon_core::account::AccountDecoder, solana_pubkey::Pubkey};

    const TOKEN_2022_PROGRAM_ID: Pubkey =
        solana_pubkey::Pubkey::from_str_const("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");

    fn create_base_mint_data() -> Vec<u8> {
        let mut data = vec![0u8; 82];
        data[0] = 1; // mint_authority: Some
        data[4..36].copy_from_slice(&[1u8; 32]);
        data[36..44].copy_from_slice(&1_000_000_000u64.to_le_bytes()); // supply
        data[44] = 9; // decimals
        data[45] = 1; // is_initialized
        data
    }

    fn create_base_token_account_data() -> Vec<u8> {
        let mut data = vec![0u8; 165];
        data[0..32].copy_from_slice(&[2u8; 32]); // mint
        data[32..64].copy_from_slice(&[3u8; 32]); // owner
        data[64..72].copy_from_slice(&500_000_000u64.to_le_bytes()); // amount
        data[108] = 1; // state: Initialized
        data
    }

    #[test]
    fn test_decode_base_mint_account() {
        let decoder = {{ program.name | pascalCase }}Decoder;
        let account = solana_account::Account {
            lamports: 1_000_000,
            data: create_base_mint_data(),
            owner: TOKEN_2022_PROGRAM_ID,
            executable: false,
            rent_epoch: 0,
        };

        let result = decoder.decode_account(&account);
        assert!(result.is_some(), "Should decode base Mint account");
        match result.unwrap().data {
            {{ program.name | pascalCase }}Account::Mint(mint) => {
                assert_eq!(mint.supply, 1_000_000_000);
                assert_eq!(mint.decimals, 9);
            }
            _ => panic!("Expected Mint account"),
        }
    }

    #[test]
    fn test_decode_base_token_account() {
        let decoder = {{ program.name | pascalCase }}Decoder;
        let account = solana_account::Account {
            lamports: 1_000_000,
            data: create_base_token_account_data(),
            owner: TOKEN_2022_PROGRAM_ID,
            executable: false,
            rent_epoch: 0,
        };

        let result = decoder.decode_account(&account);
        assert!(result.is_some(), "Should decode base Token account");
        match result.unwrap().data {
            {{ program.name | pascalCase }}Account::Token(token) => {
                assert_eq!(token.amount, 500_000_000);
            }
            _ => panic!("Expected Token account"),
        }
    }

    #[test]
    fn test_decode_multisig_account() {
        let decoder = {{ program.name | pascalCase }}Decoder;
        let mut data = vec![0u8; 355];
        data[0] = 2; // m
        data[1] = 3; // n
        data[2] = 1; // is_initialized

        let account = solana_account::Account {
            lamports: 1_000_000,
            data,
            owner: TOKEN_2022_PROGRAM_ID,
            executable: false,
            rent_epoch: 0,
        };

        let result = decoder.decode_account(&account);
        assert!(result.is_some(), "Should decode Multisig account");
        match result.unwrap().data {
            {{ program.name | pascalCase }}Account::Multisig(ms) => {
                assert_eq!(ms.m, 2);
                assert_eq!(ms.n, 3);
            }
            _ => panic!("Expected Multisig account"),
        }
    }

    #[test]
    fn test_wrong_owner_returns_none() {
        let decoder = {{ program.name | pascalCase }}Decoder;
        let account = solana_account::Account {
            lamports: 1_000_000,
            data: create_base_mint_data(),
            owner: Pubkey::new_unique(),
            executable: false,
            rent_epoch: 0,
        };
        assert!(decoder.decode_account(&account).is_none());
    }

    /// Regression test: decoder must handle various account sizes without panic.
    #[test]
    fn test_no_panic_on_various_sizes() {
        let decoder = {{ program.name | pascalCase }}Decoder;

        for size in [
            0, 1, 50, 81, 82, 83, 100, 164, 165, 166, 200, 354, 355, 356, 500,
        ] {
            let account = solana_account::Account {
                lamports: 1_000_000,
                data: vec![0u8; size],
                owner: TOKEN_2022_PROGRAM_ID,
                executable: false,
                rent_epoch: 0,
            };
            // Must not panic
            let _ = decoder.decode_account(&account);
        }
    }
}
{% endif %}

{% endblock %}