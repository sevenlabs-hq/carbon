impl Extension {
    pub fn from_mint_and_type(
        state_with_extensions: &StateWithExtensions<'_, spl_token_2022::state::Mint>,
        extension_type: &spl_token_2022::extension::ExtensionType,
    ) -> Option<Self> {
        match extension_type {
            ExtensionType::Uninitialized => None,
            ExtensionType::TransferFeeConfig => {
                state_with_extensions.get_extension::<spl_token_2022::extension::transfer_fee::TransferFeeConfig>().map(|extension| Extension::TransferFeeConfig {
                        transfer_fee_config_authority: extension.transfer_fee_config_authority.0,
                        withdraw_withheld_authority: extension.withdraw_withheld_authority.0,
                        withheld_amount: extension.withheld_amount.into(),
                        older_transfer_fee: TransferFee {
                            epoch: extension.older_transfer_fee.epoch.into(),
                            maximum_fee: extension.older_transfer_fee.maximum_fee.into(),
                            transfer_fee_basis_points: extension.older_transfer_fee.transfer_fee_basis_points.into(),
                        },
                        newer_transfer_fee: TransferFee {
                            epoch: extension.newer_transfer_fee.epoch.into(),
                            maximum_fee: extension.newer_transfer_fee.maximum_fee.into(),
                            transfer_fee_basis_points: extension.newer_transfer_fee.transfer_fee_basis_points.into(),
                        },
                    }).ok()
            }
            ExtensionType::MintCloseAuthority => {
                state_with_extensions.get_extension::<spl_token_2022::extension::mint_close_authority::MintCloseAuthority>().map(|extension| Extension::MintCloseAuthority {
                    close_authority: extension.close_authority.0,
                }).ok()
            }
            ExtensionType::ConfidentialTransferMint => {
                state_with_extensions.get_extension::<spl_token_2022::extension::confidential_transfer::ConfidentialTransferMint>().map(|extension| Some(Extension::ConfidentialTransferMint {
                    authority: extension.authority.into(),
                    auto_approve_new_accounts: extension.auto_approve_new_accounts.into(),
                    auditor_elgamal_pubkey: Option::<PodElGamalPubkey>::from(extension.auditor_elgamal_pubkey).and_then(|pubkey| ElGamalPubkey::try_from(pubkey).ok().map(|elgamal| Pubkey::new_from_array(elgamal.into()))),
                })).ok().flatten()
            }
            ExtensionType::DefaultAccountState => {
                state_with_extensions.get_extension::<spl_token_2022::extension::default_account_state::DefaultAccountState>().map(|extension| Some(Extension::DefaultAccountState {
                    state: match extension.state {
                        0 => AccountState::Uninitialized,
                        1 => AccountState::Initialized,
                        2 => AccountState::Frozen,
                        _ => return None,
                    }
                })).ok().flatten()
            }
            ExtensionType::NonTransferable => {
                state_with_extensions.get_extension::<spl_token_2022::extension::non_transferable::NonTransferable>().map(|_extension| Extension::NonTransferable {}).ok()
            }
            ExtensionType::InterestBearingConfig => {
                state_with_extensions.get_extension::<spl_token_2022::extension::interest_bearing_mint::InterestBearingConfig>().map(|extension| Extension::InterestBearingConfig {
                    rate_authority: extension.rate_authority.0,
                    // SAFETY: PodI64 and u64 have the same size (8 bytes) and alignment.
                    // PodI64 is a transparent wrapper around i64, and we're converting to u64 for timestamp representation.
                    // This is safe because we're only reading the bytes, not modifying memory layout.
                    initialization_timestamp: unsafe { std::mem::transmute::<PodI64, u64>(extension.initialization_timestamp) },
                    pre_update_average_rate: extension.pre_update_average_rate.into(),
                    // SAFETY: PodI64 and u64 have the same size (8 bytes) and alignment.
                    // PodI64 is a transparent wrapper around i64, and we're converting to u64 for timestamp representation.
                    // This is safe because we're only reading the bytes, not modifying memory layout.
                    last_update_timestamp: unsafe { std::mem::transmute::<PodI64, u64>(extension.last_update_timestamp) },
                    current_rate: extension.current_rate.into(),
                }).ok()
            }
            ExtensionType::PermanentDelegate => {
                state_with_extensions.get_extension::<spl_token_2022::extension::permanent_delegate::PermanentDelegate>().map(|extension| Extension::PermanentDelegate {
                    delegate: extension.delegate.0,
                }).ok()
            }
            ExtensionType::TransferHook => {
                state_with_extensions.get_extension::<spl_token_2022::extension::transfer_hook::TransferHook>().map(|extension| Extension::TransferHook {
                    authority: extension.authority.0,
                    program_id: extension.program_id.0,
                }).ok()
            }
            ExtensionType::ConfidentialTransferFeeConfig => {
                state_with_extensions.get_extension::<spl_token_2022::extension::confidential_transfer_fee::ConfidentialTransferFeeConfig>().map(|extension| {
                    if let (Some(elgamal_pubkey), Some(withheld_amount)) = (
                        ElGamalPubkey::try_from(extension.withdraw_withheld_authority_elgamal_pubkey).ok(),
                        spl_token_2022::solana_zk_sdk::encryption::elgamal::ElGamalCiphertext::try_from(extension.withheld_amount).ok(),
                    ) {
                        Some(Extension::ConfidentialTransferFee {
                            authority: extension.authority.into(),
                            harvest_to_mint_enabled: extension.harvest_to_mint_enabled.into(),
                            elgamal_pubkey: Pubkey::new_from_array(elgamal_pubkey.into()),
                            withheld_amount: EncryptedBalance(withheld_amount.to_bytes()),
                        })
                    } else {
                        None
                    }
                }).ok().flatten()
            }
            ExtensionType::MetadataPointer => {
                state_with_extensions.get_extension::<spl_token_2022::extension::metadata_pointer::MetadataPointer>().map(|extension| Extension::MetadataPointer {
                        authority: extension.authority.into(),
                        metadata_address: extension.metadata_address.into(),
                    }).ok()
            }
            ExtensionType::TokenMetadata => {
                state_with_extensions.get_extension_bytes::<spl_token_metadata_interface::state::TokenMetadata>().map(|extension| spl_token_metadata_interface::state::TokenMetadata::unpack_from_slice(extension).ok().map(|extension| Extension::TokenMetadata {
                        update_authority: extension.update_authority.into(),
                        mint: extension.mint,
                        name: extension.name,
                        symbol: extension.symbol,
                        uri: extension.uri,
                        additional_metadata: extension.additional_metadata.iter().map(|(key, value)| (key.clone(), value.clone())).collect(),
                    })).ok().flatten()
            },
            ExtensionType::GroupPointer => {
                state_with_extensions.get_extension::<spl_token_2022::extension::group_pointer::GroupPointer>().map(|extension| Extension::GroupPointer {
                    authority: extension.authority.into(),
                    group_address: extension.group_address.into(),
                }).ok()
            }
            ExtensionType::TokenGroup => {
                state_with_extensions.get_extension_bytes::<spl_token_group_interface::state::TokenGroup>().map(|extension| spl_pod::bytemuck::pod_from_bytes::<spl_token_group_interface::state::TokenGroup>(extension).ok().map(|extension| Extension::TokenGroup {
                        update_authority: extension.update_authority.into(),
                        mint: extension.mint,
                        size: extension.size.into(),
                        max_size: extension.max_size.into(),
                    })).ok().flatten()
            },
            ExtensionType::GroupMemberPointer => {
                state_with_extensions.get_extension::<spl_token_2022::extension::group_member_pointer::GroupMemberPointer>().map(|extension| Extension::GroupMemberPointer {
                    authority: extension.authority.into(),
                    member_address: extension.member_address.into(),
                }).ok()
            }
            ExtensionType::ConfidentialMintBurn => {
                state_with_extensions.get_extension::<spl_token_2022::extension::confidential_mint_burn::ConfidentialMintBurn>().map(|_extension| Extension::ConfidentialMintBurn).ok()
            }
            ExtensionType::TokenGroupMember => {
                state_with_extensions.get_extension_bytes::<spl_token_group_interface::state::TokenGroupMember>().map(|extension| spl_pod::bytemuck::pod_from_bytes::<spl_token_group_interface::state::TokenGroupMember>(extension).ok().map(|extension| Extension::TokenGroupMember {
                        mint: extension.mint,
                        group: extension.group,
                        member_number: extension.member_number.into(),
                    })).ok().flatten()
            },
            ExtensionType::ScaledUiAmount => {
                state_with_extensions.get_extension::<spl_token_2022::extension::scaled_ui_amount::ScaledUiAmountConfig>().map(|extension| Extension::ScaledUiAmountConfig {
                        authority: extension.authority.0,
                        multiplier: extension.multiplier.into(),
                        // SAFETY: PodI64 and [u8; 8] have the same size (8 bytes) and alignment.
                        // PodI64 is a transparent wrapper around i64, and we're converting to byte array for timestamp representation.
                        // This is safe because we're only reading the bytes, not modifying memory layout.
                        new_multiplier_effective_timestamp: u64::from_le_bytes(unsafe { std::mem::transmute::<PodI64, [u8; 8]>(extension.new_multiplier_effective_timestamp)}),
                        new_multiplier: extension.new_multiplier.into(),
                    }).ok()
            }
            ExtensionType::Pausable => {
                state_with_extensions.get_extension::<spl_token_2022::extension::pausable::PausableConfig>().map(|extension| Extension::PausableConfig {
                    authority: extension.authority.into(),
                    paused: extension.paused.into(),
                }).ok()
            }
            _ => None,
        }
    }

    pub fn from_account_and_type(
        state_with_extensions: &StateWithExtensions<'_, spl_token_2022::state::Account>,
        extension_type: &spl_token_2022::extension::ExtensionType,
    ) -> Option<Self> {
        match extension_type {
            ExtensionType::TransferFeeAmount => {
                state_with_extensions.get_extension::<spl_token_2022::extension::transfer_fee::TransferFeeAmount>().map(|extension| Extension::TransferFeeAmount {
                        withheld_amount: extension.withheld_amount.into(),
                    }).ok()
            }
            ExtensionType::ConfidentialTransferAccount => {
                state_with_extensions.get_extension::<spl_token_2022::extension::confidential_transfer::ConfidentialTransferAccount>().map(|extension| {
                    if let (Some(elgamal_pubkey), Some(pending_balance_lo), Some(pending_balance_hi), Some(available_balance), Some(decryptable_available_balance)) = (
                        ElGamalPubkey::try_from(extension.elgamal_pubkey).ok(),
                        spl_token_2022::solana_zk_sdk::encryption::elgamal::ElGamalCiphertext::try_from(extension.pending_balance_lo).ok(),
                        spl_token_2022::solana_zk_sdk::encryption::elgamal::ElGamalCiphertext::try_from(extension.pending_balance_hi).ok(),
                        spl_token_2022::solana_zk_sdk::encryption::elgamal::ElGamalCiphertext::try_from(extension.available_balance).ok(),
                        spl_token_2022::solana_zk_sdk::encryption::auth_encryption::AeCiphertext::try_from(extension.decryptable_available_balance).ok(),
                    ) {
                        Some(Extension::ConfidentialTransferAccount {
                            approved: extension.approved.into(),
                            elgamal_pubkey: Pubkey::new_from_array(elgamal_pubkey.into()),
                            pending_balance_low: EncryptedBalance(pending_balance_lo.to_bytes()),
                            pending_balance_high: EncryptedBalance(pending_balance_hi.to_bytes()),
                            available_balance: EncryptedBalance(available_balance.to_bytes()),
                            decryptable_available_balance: DecryptableBalance(decryptable_available_balance.to_bytes()),
                            allow_confidential_credits: extension.allow_confidential_credits.into(),
                            allow_non_confidential_credits: extension.allow_non_confidential_credits.into(),
                            pending_balance_credit_counter: extension.pending_balance_credit_counter.into(),
                            maximum_pending_balance_credit_counter: extension.maximum_pending_balance_credit_counter.into(),
                            expected_pending_balance_credit_counter: extension.expected_pending_balance_credit_counter.into(),
                            actual_pending_balance_credit_counter: extension.actual_pending_balance_credit_counter.into(),
                        })
                    } else {
                        None
                    }
                }).ok().flatten()
            }
            ExtensionType::MemoTransfer => {
                state_with_extensions.get_extension::<spl_token_2022::extension::memo_transfer::MemoTransfer>().map(|extension| Extension::MemoTransfer {
                    require_incoming_transfer_memos: extension.require_incoming_transfer_memos.into()
                }).ok()
            }
            ExtensionType::NonTransferableAccount => {
                state_with_extensions.get_extension::<spl_token_2022::extension::non_transferable::NonTransferableAccount>().map(|_extension| Extension::NonTransferableAccount {}).ok()
            }
            ExtensionType::TransferHookAccount => {
                state_with_extensions.get_extension::<spl_token_2022::extension::transfer_hook::TransferHookAccount>().map(|extension| Extension::TransferHookAccount {
                    transferring: extension.transferring.into(),
                }).ok()
            }
            ExtensionType::CpiGuard => {
                    state_with_extensions.get_extension::<spl_token_2022::extension::cpi_guard::CpiGuard>().map(|extension| Extension::CpiGuard {
                    lock_cpi: extension.lock_cpi.into(),
                }).ok()
            }
            ExtensionType::ConfidentialTransferFeeAmount => {
                state_with_extensions.get_extension::<spl_token_2022::extension::confidential_transfer_fee::ConfidentialTransferFeeAmount>().map(|extension| {
                    spl_token_2022::solana_zk_sdk::encryption::elgamal::ElGamalCiphertext::try_from(extension.withheld_amount).ok().map(|withheld_amount| {
                        Extension::ConfidentialTransferFeeAmount {
                            withheld_amount: EncryptedBalance(withheld_amount.to_bytes()),
                        }
                    })
                }).ok().flatten()
            }
            ExtensionType::PausableAccount => {
                state_with_extensions.get_extension::<spl_token_2022::extension::pausable::PausableAccount>().map(|_extension| Extension::PausableAccount).ok()
            }
            _ => None,
        }
    }
}

