//! This code was AUTOGENERATED using the Codama library.
pub mod claim_row;
pub mod cpi_event_row;
pub mod create_token_account_row;
pub mod create_token_account_with_seed_row;
pub mod proxy_swap_row;
pub mod swap_row;
pub mod swap_tob_enhanced_row;
pub mod swap_tob_row;
pub mod swap_tob_with_receiver_row;
pub mod swap_toc_row;
pub mod swap_toc_v2_row;
pub mod wrap_unwrap_row;
pub mod wrap_unwrap_with_receiver_row;

pub use self::{
    claim_row::*, cpi_event_row::*, create_token_account_row::*,
    create_token_account_with_seed_row::*, proxy_swap_row::*, swap_row::*,
    swap_tob_enhanced_row::*, swap_tob_row::*, swap_tob_with_receiver_row::*, swap_toc_row::*,
    swap_toc_v2_row::*, wrap_unwrap_row::*, wrap_unwrap_with_receiver_row::*,
};
use super::OnchainLabsDexV2Instruction;

pub struct OnchainLabsDexV2InstructionsMigration;

impl sqlx_migrator::Migration<sqlx::Postgres> for OnchainLabsDexV2InstructionsMigration {
    fn app(&self) -> &str {
        "onchain-labs-dex-v2"
    }

    fn name(&self) -> &str {
        "onchain_labs_dex_v2_instructions"
    }

    fn operations(&self) -> Vec<Box<dyn sqlx_migrator::Operation<sqlx::Postgres>>> {
        vec![
            Box::new(ClaimMigrationOperation),
            Box::new(CreateTokenAccountMigrationOperation),
            Box::new(CreateTokenAccountWithSeedMigrationOperation),
            Box::new(ProxySwapMigrationOperation),
            Box::new(SwapMigrationOperation),
            Box::new(SwapTobMigrationOperation),
            Box::new(SwapTobEnhancedMigrationOperation),
            Box::new(SwapTobWithReceiverMigrationOperation),
            Box::new(SwapTocMigrationOperation),
            Box::new(SwapTocV2MigrationOperation),
            Box::new(WrapUnwrapMigrationOperation),
            Box::new(WrapUnwrapWithReceiverMigrationOperation),
            Box::new(CpiEventMigrationOperation),
        ]
    }

    fn parents(&self) -> Vec<Box<dyn sqlx_migrator::Migration<sqlx::Postgres>>> {
        vec![]
    }
}

pub struct OnchainLabsDexV2InstructionWithMetadata(
    pub OnchainLabsDexV2Instruction,
    pub carbon_core::instruction::InstructionMetadata,
    pub Vec<solana_instruction::AccountMeta>,
);

impl
    From<(
        OnchainLabsDexV2Instruction,
        carbon_core::instruction::InstructionMetadata,
        Vec<solana_instruction::AccountMeta>,
    )> for OnchainLabsDexV2InstructionWithMetadata
{
    fn from(
        value: (
            OnchainLabsDexV2Instruction,
            carbon_core::instruction::InstructionMetadata,
            Vec<solana_instruction::AccountMeta>,
        ),
    ) -> Self {
        OnchainLabsDexV2InstructionWithMetadata(value.0, value.1, value.2)
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::Insert for OnchainLabsDexV2InstructionWithMetadata {
    async fn insert(&self, pool: &sqlx::PgPool) -> carbon_core::error::CarbonResult<()> {
        let OnchainLabsDexV2InstructionWithMetadata(instruction, metadata, accounts) = self;
        match instruction {
            OnchainLabsDexV2Instruction::Claim(instruction) => {
                let row = claim_row::ClaimRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                    accounts.clone(),
                );
                row.insert(pool).await?;
                Ok(())
            }
            OnchainLabsDexV2Instruction::CreateTokenAccount(instruction) => {
                let row = create_token_account_row::CreateTokenAccountRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                    accounts.clone(),
                );
                row.insert(pool).await?;
                Ok(())
            }
            OnchainLabsDexV2Instruction::CreateTokenAccountWithSeed(instruction) => {
                let row =
                    create_token_account_with_seed_row::CreateTokenAccountWithSeedRow::from_parts(
                        instruction.clone(),
                        metadata.clone(),
                        accounts.clone(),
                    );
                row.insert(pool).await?;
                Ok(())
            }
            OnchainLabsDexV2Instruction::ProxySwap(instruction) => {
                let row = proxy_swap_row::ProxySwapRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                    accounts.clone(),
                );
                row.insert(pool).await?;
                Ok(())
            }
            OnchainLabsDexV2Instruction::Swap(instruction) => {
                let row = swap_row::SwapRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                    accounts.clone(),
                );
                row.insert(pool).await?;
                Ok(())
            }
            OnchainLabsDexV2Instruction::SwapTob(instruction) => {
                let row = swap_tob_row::SwapTobRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                    accounts.clone(),
                );
                row.insert(pool).await?;
                Ok(())
            }
            OnchainLabsDexV2Instruction::SwapTobEnhanced(instruction) => {
                let row = swap_tob_enhanced_row::SwapTobEnhancedRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                    accounts.clone(),
                );
                row.insert(pool).await?;
                Ok(())
            }
            OnchainLabsDexV2Instruction::SwapTobWithReceiver(instruction) => {
                let row = swap_tob_with_receiver_row::SwapTobWithReceiverRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                    accounts.clone(),
                );
                row.insert(pool).await?;
                Ok(())
            }
            OnchainLabsDexV2Instruction::SwapToc(instruction) => {
                let row = swap_toc_row::SwapTocRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                    accounts.clone(),
                );
                row.insert(pool).await?;
                Ok(())
            }
            OnchainLabsDexV2Instruction::SwapTocV2(instruction) => {
                let row = swap_toc_v2_row::SwapTocV2Row::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                    accounts.clone(),
                );
                row.insert(pool).await?;
                Ok(())
            }
            OnchainLabsDexV2Instruction::WrapUnwrap(instruction) => {
                let row = wrap_unwrap_row::WrapUnwrapRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                    accounts.clone(),
                );
                row.insert(pool).await?;
                Ok(())
            }
            OnchainLabsDexV2Instruction::WrapUnwrapWithReceiver(instruction) => {
                let row = wrap_unwrap_with_receiver_row::WrapUnwrapWithReceiverRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                    accounts.clone(),
                );
                row.insert(pool).await?;
                Ok(())
            }
            OnchainLabsDexV2Instruction::CpiEvent(instruction) => {
                let row = cpi_event_row::CpiEventRow::from_parts(
                    (**instruction).clone(),
                    metadata.clone(),
                    accounts.clone(),
                );
                row.insert(pool).await?;
                Ok(())
            }
        }
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::Upsert for OnchainLabsDexV2InstructionWithMetadata {
    async fn upsert(&self, pool: &sqlx::PgPool) -> carbon_core::error::CarbonResult<()> {
        let OnchainLabsDexV2InstructionWithMetadata(instruction, metadata, accounts) = self;
        match instruction {
            OnchainLabsDexV2Instruction::Claim(instruction) => {
                let row = claim_row::ClaimRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                    accounts.clone(),
                );
                row.upsert(pool).await?;
                Ok(())
            }
            OnchainLabsDexV2Instruction::CreateTokenAccount(instruction) => {
                let row = create_token_account_row::CreateTokenAccountRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                    accounts.clone(),
                );
                row.upsert(pool).await?;
                Ok(())
            }
            OnchainLabsDexV2Instruction::CreateTokenAccountWithSeed(instruction) => {
                let row =
                    create_token_account_with_seed_row::CreateTokenAccountWithSeedRow::from_parts(
                        instruction.clone(),
                        metadata.clone(),
                        accounts.clone(),
                    );
                row.upsert(pool).await?;
                Ok(())
            }
            OnchainLabsDexV2Instruction::ProxySwap(instruction) => {
                let row = proxy_swap_row::ProxySwapRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                    accounts.clone(),
                );
                row.upsert(pool).await?;
                Ok(())
            }
            OnchainLabsDexV2Instruction::Swap(instruction) => {
                let row = swap_row::SwapRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                    accounts.clone(),
                );
                row.upsert(pool).await?;
                Ok(())
            }
            OnchainLabsDexV2Instruction::SwapTob(instruction) => {
                let row = swap_tob_row::SwapTobRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                    accounts.clone(),
                );
                row.upsert(pool).await?;
                Ok(())
            }
            OnchainLabsDexV2Instruction::SwapTobEnhanced(instruction) => {
                let row = swap_tob_enhanced_row::SwapTobEnhancedRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                    accounts.clone(),
                );
                row.upsert(pool).await?;
                Ok(())
            }
            OnchainLabsDexV2Instruction::SwapTobWithReceiver(instruction) => {
                let row = swap_tob_with_receiver_row::SwapTobWithReceiverRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                    accounts.clone(),
                );
                row.upsert(pool).await?;
                Ok(())
            }
            OnchainLabsDexV2Instruction::SwapToc(instruction) => {
                let row = swap_toc_row::SwapTocRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                    accounts.clone(),
                );
                row.upsert(pool).await?;
                Ok(())
            }
            OnchainLabsDexV2Instruction::SwapTocV2(instruction) => {
                let row = swap_toc_v2_row::SwapTocV2Row::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                    accounts.clone(),
                );
                row.upsert(pool).await?;
                Ok(())
            }
            OnchainLabsDexV2Instruction::WrapUnwrap(instruction) => {
                let row = wrap_unwrap_row::WrapUnwrapRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                    accounts.clone(),
                );
                row.upsert(pool).await?;
                Ok(())
            }
            OnchainLabsDexV2Instruction::WrapUnwrapWithReceiver(instruction) => {
                let row = wrap_unwrap_with_receiver_row::WrapUnwrapWithReceiverRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                    accounts.clone(),
                );
                row.upsert(pool).await?;
                Ok(())
            }
            OnchainLabsDexV2Instruction::CpiEvent(instruction) => {
                let row = cpi_event_row::CpiEventRow::from_parts(
                    (**instruction).clone(),
                    metadata.clone(),
                    accounts.clone(),
                );
                row.upsert(pool).await?;
                Ok(())
            }
        }
    }
}
