//! This code was AUTOGENERATED using the Codama library.
use crate::{PumpfunDecoder, PROGRAM_ID};

#[cfg(feature = "postgres")]
pub mod postgres;

#[cfg(feature = "graphql")]
pub mod graphql;

pub mod bonding_curve;
pub mod fee_config;
pub mod global;
pub mod global_volume_accumulator;
pub mod user_volume_accumulator;

#[derive(Debug, Clone, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[cfg_attr(feature = "serde", serde(tag = "type", content = "data"))]
pub enum PumpfunAccount {
    BondingCurve(Box<bonding_curve::BondingCurve>),
    FeeConfig(Box<fee_config::FeeConfig>),
    Global(Box<global::Global>),
    GlobalVolumeAccumulator(Box<global_volume_accumulator::GlobalVolumeAccumulator>),
    UserVolumeAccumulator(Box<user_volume_accumulator::UserVolumeAccumulator>),
}

impl<'a> carbon_core::account::AccountDecoder<'a> for PumpfunDecoder {
    type AccountType = PumpfunAccount;

    fn decode_account(
        &self,
        account: &'a solana_account::Account,
    ) -> Option<carbon_core::account::DecodedAccount<Self::AccountType>> {
        if account.owner != PROGRAM_ID {
            return None;
        }

        let data = account.data.as_slice();

        {
            if let Some(decoded) = bonding_curve::BondingCurve::decode(data) {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: PumpfunAccount::BondingCurve(Box::new(decoded)),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }
        {
            if let Some(decoded) = fee_config::FeeConfig::decode(data) {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: PumpfunAccount::FeeConfig(Box::new(decoded)),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }
        {
            if let Some(decoded) = global::Global::decode(data) {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: PumpfunAccount::Global(Box::new(decoded)),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }
        {
            if let Some(decoded) = global_volume_accumulator::GlobalVolumeAccumulator::decode(data)
            {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: PumpfunAccount::GlobalVolumeAccumulator(Box::new(decoded)),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }
        {
            if let Some(decoded) = user_volume_accumulator::UserVolumeAccumulator::decode(data) {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: PumpfunAccount::UserVolumeAccumulator(Box::new(decoded)),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }

        None
    }
}
