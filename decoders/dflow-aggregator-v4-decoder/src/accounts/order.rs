//! This code was AUTOGENERATED using the Codama library.
use carbon_core::borsh;
use carbon_core::deserialize::CarbonDeserialize;
use carbon_core::CarbonDeserialize;
use solana_pubkey::Pubkey;

#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[derive(Debug, Clone, borsh::BorshSerialize, CarbonDeserialize, PartialEq)]
pub struct Order {
    /// Account that is authorized to close the order
    pub closer: Pubkey,
    /// Account to which output from the fill should be sent. If the order specifies that it should
    /// output native SOL, then this should be the user's wallet, although any account is allowed.
    /// If the order doesn't specify that it should output native SOL, then this must be an SPL
    /// token account, and the token account's mint determines the order's output mint.
    pub output_token_account: Pubkey,
    /// Account to which leftover tokens in the order vault should be returned when the order is
    /// filled or closed. If the input is native SOL, this should be the user's wallet, although any
    /// account is allowed. If the input is wrapped SOL or an SPL token, this must be an SPL token
    /// account for the input mint.
    pub return_input_token_account: Pubkey,
    /// Account to which rent for the account should be returned when the account is closed
    pub return_rent_to: Pubkey,
    /// ID used to produce a unique PDA for the order account
    pub id: u64,
    pub quoted_out_amount: u64,
    /// Highest slot at which the order can be filled
    pub last_fillable_slot: u64,
    /// Max allowed slippage in basis points. Along with `quoted_out_amount`, this is used to
    /// calculate the minimum allowed output amount for the order.
    pub slippage_bps: u16,
    pub bump: u8,
    /// Bump seed for the vault token account associated with the order
    pub vault_bump: u8,
    /// Flags for the order
    pub flags: u8,
    pub padding1: u8,
    pub padding2: u8,
    pub padding3: u8,
}

impl Order {
    pub fn decode(data: &[u8]) -> Option<Self> {
        if data.len() < 8 {
            return None;
        }
        let discriminator = &data[0..8];
        if discriminator != [134, 173, 223, 185, 77, 86, 28, 51] {
            return None;
        }

        let data_slice = data;

        let data_slice = &data_slice[8..];

        Self::deserialize(data_slice)
    }
}
