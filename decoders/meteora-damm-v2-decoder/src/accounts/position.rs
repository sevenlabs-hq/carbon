//! This code was AUTOGENERATED using the Codama library.
use {
    crate::types::{PositionMetrics, UserRewardInfo},
    solana_pubkey::Pubkey,
};

#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[derive(Debug, Clone, borsh::BorshSerialize, borsh::BorshDeserialize, PartialEq)]
pub struct Position {
    pub pool: Pubkey,
    /// nft mint
    pub nft_mint: Pubkey,
    /// fee a checkpoint
    pub fee_a_per_token_checkpoint: [u8; 32],
    /// fee b checkpoint
    pub fee_b_per_token_checkpoint: [u8; 32],
    /// fee a pending
    pub fee_a_pending: u64,
    /// fee b pending
    pub fee_b_pending: u64,
    /// unlock liquidity
    pub unlocked_liquidity: u128,
    /// vesting liquidity
    pub vested_liquidity: u128,
    /// permanent locked liquidity
    pub permanent_locked_liquidity: u128,
    /// metrics
    pub metrics: PositionMetrics,
    /// Farming reward information
    pub reward_infos: [UserRewardInfo; 2],
    /// padding for future usage
    pub padding: [u128; 6],
}

impl Position {
    pub fn decode(data: &[u8]) -> Option<Self> {
        if data.len() < 8 {
            return None;
        }
        let discriminator = &data[0..8];
        if discriminator != [170, 188, 143, 228, 122, 64, 247, 208] {
            return None;
        }

        let mut data_slice = data;

        data_slice = &data_slice[8..];

        borsh::BorshDeserialize::deserialize(&mut data_slice).ok()
    }
}
