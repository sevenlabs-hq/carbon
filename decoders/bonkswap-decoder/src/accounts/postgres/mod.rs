//! This code was AUTOGENERATED using the Codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun Codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

pub mod farm_row;
pub mod pool_row;
pub mod pool_v2_row;
pub mod provider_row;
pub mod state_row;

pub use self::farm_row::*;
pub use self::pool_row::*;
pub use self::pool_v2_row::*;
pub use self::provider_row::*;
pub use self::state_row::*;

use super::BonkswapAccount;

pub struct BonkswapAccountsMigration;

impl sqlx_migrator::Migration<sqlx::Postgres> for BonkswapAccountsMigration {
    fn app(&self) -> &str {
        "bonkswap"
    }

    fn name(&self) -> &str {
        "bonkswap_accounts"
    }

    fn operations(&self) -> Vec<Box<dyn sqlx_migrator::Operation<sqlx::Postgres>>> {
        vec![
            Box::new(FarmMigrationOperation),
            Box::new(PoolMigrationOperation),
            Box::new(PoolV2MigrationOperation),
            Box::new(ProviderMigrationOperation),
            Box::new(StateMigrationOperation),
        ]
    }

    fn parents(&self) -> Vec<Box<dyn sqlx_migrator::Migration<sqlx::Postgres>>> {
        vec![]
    }
}

pub struct BonkswapAccountWithMetadata(
    pub BonkswapAccount,
    pub carbon_core::account::AccountMetadata,
);

impl From<(BonkswapAccount, carbon_core::account::AccountMetadata)>
    for BonkswapAccountWithMetadata
{
    fn from(value: (BonkswapAccount, carbon_core::account::AccountMetadata)) -> Self {
        BonkswapAccountWithMetadata(value.0, value.1)
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::Insert for BonkswapAccountWithMetadata {
    async fn insert(&self, pool: &sqlx::PgPool) -> carbon_core::error::CarbonResult<()> {
        let BonkswapAccountWithMetadata(account, metadata) = self;

        match account {
            BonkswapAccount::Farm(account) => {
                let row = farm_row::FarmRow::from_parts(account.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
            BonkswapAccount::PoolV2(account) => {
                let row = pool_v2_row::PoolV2Row::from_parts(account.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
            BonkswapAccount::Pool(account) => {
                let row = pool_row::PoolRow::from_parts(account.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
            BonkswapAccount::Provider(account) => {
                let row = provider_row::ProviderRow::from_parts(account.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
            BonkswapAccount::State(account) => {
                let row = state_row::StateRow::from_parts(account.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
        }
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::Upsert for BonkswapAccountWithMetadata {
    async fn upsert(&self, pool: &sqlx::PgPool) -> carbon_core::error::CarbonResult<()> {
        let BonkswapAccountWithMetadata(account, metadata) = self;
        match account {
            BonkswapAccount::Farm(account) => {
                let row = farm_row::FarmRow::from_parts(account.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
            BonkswapAccount::PoolV2(account) => {
                let row = pool_v2_row::PoolV2Row::from_parts(account.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
            BonkswapAccount::Pool(account) => {
                let row = pool_row::PoolRow::from_parts(account.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
            BonkswapAccount::Provider(account) => {
                let row = provider_row::ProviderRow::from_parts(account.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
            BonkswapAccount::State(account) => {
                let row = state_row::StateRow::from_parts(account.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
        }
    }
}
