//! This code was AUTOGENERATED using the Codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun Codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use crate::{BonkswapDecoder, PROGRAM_ID};

#[cfg(feature = "postgres")]
pub mod postgres;

#[cfg(feature = "graphql")]
pub mod graphql;

pub mod farm;
pub mod pool;
pub mod pool_v2;
pub mod provider;
pub mod state;

pub use self::farm::*;
pub use self::pool::*;
pub use self::pool_v2::*;
pub use self::provider::*;
pub use self::state::*;

#[derive(Debug, Clone, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[cfg_attr(feature = "serde", serde(tag = "type", content = "data"))]
pub enum BonkswapAccount {
    Farm(Farm),
    Pool(Pool),
    PoolV2(PoolV2),
    Provider(Provider),
    State(State),
}

impl<'a> carbon_core::account::AccountDecoder<'a> for BonkswapDecoder {
    type AccountType = BonkswapAccount;

    fn decode_account(
        &self,
        account: &'a solana_account::Account,
    ) -> Option<carbon_core::account::DecodedAccount<Self::AccountType>> {
        if account.owner != PROGRAM_ID {
            return None;
        }

        let data = account.data.as_slice();

        // Try to decode Farm
        {
            if let Some(decoded) = farm::Farm::decode(data) {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: BonkswapAccount::Farm(decoded),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }
        // Try to decode PoolV2
        {
            if let Some(decoded) = pool_v2::PoolV2::decode(data) {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: BonkswapAccount::PoolV2(decoded),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }
        // Try to decode Pool
        {
            if let Some(decoded) = pool::Pool::decode(data) {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: BonkswapAccount::Pool(decoded),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }
        // Try to decode Provider
        {
            if let Some(decoded) = provider::Provider::decode(data) {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: BonkswapAccount::Provider(decoded),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }
        // Try to decode State
        {
            if let Some(decoded) = state::State::decode(data) {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: BonkswapAccount::State(decoded),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }

        None
    }
}
