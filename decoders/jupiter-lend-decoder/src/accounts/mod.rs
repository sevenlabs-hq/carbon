//! This code was AUTOGENERATED using the Codama library.
use crate::{LiquidityDecoder, PROGRAM_ID};

#[cfg(feature = "postgres")]
pub mod postgres;

#[cfg(feature = "graphql")]
pub mod graphql;

pub mod authorization_list;
pub mod liquidity;
pub mod rate_model;
pub mod token_reserve;
pub mod user_borrow_position;
pub mod user_claim;
pub mod user_supply_position;

#[derive(Debug, Clone, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[cfg_attr(feature = "serde", serde(tag = "type", content = "data"))]
pub enum LiquidityAccount {
    AuthorizationList(Box<authorization_list::AuthorizationList>),
    Liquidity(Box<liquidity::Liquidity>),
    RateModel(Box<rate_model::RateModel>),
    TokenReserve(Box<token_reserve::TokenReserve>),
    UserBorrowPosition(Box<user_borrow_position::UserBorrowPosition>),
    UserClaim(Box<user_claim::UserClaim>),
    UserSupplyPosition(Box<user_supply_position::UserSupplyPosition>),
}

impl<'a> carbon_core::account::AccountDecoder<'a> for LiquidityDecoder {
    type AccountType = LiquidityAccount;

    fn decode_account(
        &self,
        account: &'a solana_account::Account,
    ) -> Option<carbon_core::account::DecodedAccount<Self::AccountType>> {
        if account.owner != PROGRAM_ID {
            return None;
        }

        let data = account.data.as_slice();

        {
            if let Some(decoded) = authorization_list::AuthorizationList::decode(data) {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: LiquidityAccount::AuthorizationList(Box::new(decoded)),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }
        {
            if let Some(decoded) = liquidity::Liquidity::decode(data) {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: LiquidityAccount::Liquidity(Box::new(decoded)),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }
        {
            if let Some(decoded) = rate_model::RateModel::decode(data) {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: LiquidityAccount::RateModel(Box::new(decoded)),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }
        {
            if let Some(decoded) = token_reserve::TokenReserve::decode(data) {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: LiquidityAccount::TokenReserve(Box::new(decoded)),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }
        {
            if let Some(decoded) = user_borrow_position::UserBorrowPosition::decode(data) {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: LiquidityAccount::UserBorrowPosition(Box::new(decoded)),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }
        {
            if let Some(decoded) = user_claim::UserClaim::decode(data) {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: LiquidityAccount::UserClaim(Box::new(decoded)),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }
        {
            if let Some(decoded) = user_supply_position::UserSupplyPosition::decode(data) {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: LiquidityAccount::UserSupplyPosition(Box::new(decoded)),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }

        None
    }
}
