//! This code was AUTOGENERATED using the Codama library.
pub mod authorization_list_row;
pub mod liquidity_row;
pub mod rate_model_row;
pub mod token_reserve_row;
pub mod user_borrow_position_row;
pub mod user_claim_row;
pub mod user_supply_position_row;

pub use self::{
    authorization_list_row::*, liquidity_row::*, rate_model_row::*, token_reserve_row::*,
    user_borrow_position_row::*, user_claim_row::*, user_supply_position_row::*,
};
use super::LiquidityAccount;

pub struct LiquidityAccountsMigration;

impl sqlx_migrator::Migration<sqlx::Postgres> for LiquidityAccountsMigration {
    fn app(&self) -> &str {
        "liquidity"
    }

    fn name(&self) -> &str {
        "liquidity_accounts"
    }

    fn operations(&self) -> Vec<Box<dyn sqlx_migrator::Operation<sqlx::Postgres>>> {
        vec![
            Box::new(AuthorizationListMigrationOperation),
            Box::new(LiquidityMigrationOperation),
            Box::new(RateModelMigrationOperation),
            Box::new(TokenReserveMigrationOperation),
            Box::new(UserBorrowPositionMigrationOperation),
            Box::new(UserClaimMigrationOperation),
            Box::new(UserSupplyPositionMigrationOperation),
        ]
    }

    fn parents(&self) -> Vec<Box<dyn sqlx_migrator::Migration<sqlx::Postgres>>> {
        vec![]
    }
}

pub struct LiquidityAccountWithMetadata(
    pub LiquidityAccount,
    pub carbon_core::account::AccountMetadata,
);

impl From<(LiquidityAccount, carbon_core::account::AccountMetadata)>
    for LiquidityAccountWithMetadata
{
    fn from(value: (LiquidityAccount, carbon_core::account::AccountMetadata)) -> Self {
        LiquidityAccountWithMetadata(value.0, value.1)
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::Insert for LiquidityAccountWithMetadata {
    async fn insert(&self, pool: &sqlx::PgPool) -> carbon_core::error::CarbonResult<()> {
        let LiquidityAccountWithMetadata(account, metadata) = self;

        match account {
            LiquidityAccount::AuthorizationList(account) => {
                let row = authorization_list_row::AuthorizationListRow::from_parts(
                    *account.clone(),
                    metadata.clone(),
                );
                row.insert(pool).await?;
                Ok(())
            }
            LiquidityAccount::Liquidity(account) => {
                let row =
                    liquidity_row::LiquidityRow::from_parts(*account.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
            LiquidityAccount::RateModel(account) => {
                let row =
                    rate_model_row::RateModelRow::from_parts(*account.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
            LiquidityAccount::TokenReserve(account) => {
                let row = token_reserve_row::TokenReserveRow::from_parts(
                    *account.clone(),
                    metadata.clone(),
                );
                row.insert(pool).await?;
                Ok(())
            }
            LiquidityAccount::UserBorrowPosition(account) => {
                let row = user_borrow_position_row::UserBorrowPositionRow::from_parts(
                    *account.clone(),
                    metadata.clone(),
                );
                row.insert(pool).await?;
                Ok(())
            }
            LiquidityAccount::UserClaim(account) => {
                let row =
                    user_claim_row::UserClaimRow::from_parts(*account.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
            LiquidityAccount::UserSupplyPosition(account) => {
                let row = user_supply_position_row::UserSupplyPositionRow::from_parts(
                    *account.clone(),
                    metadata.clone(),
                );
                row.insert(pool).await?;
                Ok(())
            }
        }
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::Upsert for LiquidityAccountWithMetadata {
    async fn upsert(&self, pool: &sqlx::PgPool) -> carbon_core::error::CarbonResult<()> {
        let LiquidityAccountWithMetadata(account, metadata) = self;
        match account {
            LiquidityAccount::AuthorizationList(account) => {
                let row = authorization_list_row::AuthorizationListRow::from_parts(
                    *account.clone(),
                    metadata.clone(),
                );
                row.upsert(pool).await?;
                Ok(())
            }
            LiquidityAccount::Liquidity(account) => {
                let row =
                    liquidity_row::LiquidityRow::from_parts(*account.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
            LiquidityAccount::RateModel(account) => {
                let row =
                    rate_model_row::RateModelRow::from_parts(*account.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
            LiquidityAccount::TokenReserve(account) => {
                let row = token_reserve_row::TokenReserveRow::from_parts(
                    *account.clone(),
                    metadata.clone(),
                );
                row.upsert(pool).await?;
                Ok(())
            }
            LiquidityAccount::UserBorrowPosition(account) => {
                let row = user_borrow_position_row::UserBorrowPositionRow::from_parts(
                    *account.clone(),
                    metadata.clone(),
                );
                row.upsert(pool).await?;
                Ok(())
            }
            LiquidityAccount::UserClaim(account) => {
                let row =
                    user_claim_row::UserClaimRow::from_parts(*account.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
            LiquidityAccount::UserSupplyPosition(account) => {
                let row = user_supply_position_row::UserSupplyPositionRow::from_parts(
                    *account.clone(),
                    metadata.clone(),
                );
                row.upsert(pool).await?;
                Ok(())
            }
        }
    }
}
