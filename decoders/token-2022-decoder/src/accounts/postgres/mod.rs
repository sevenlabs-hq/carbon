//! This code was AUTOGENERATED using the Codama library.
//!
//! <https://github.com/codama-idl/codama>
//!
pub mod mint_row;
pub mod multisig_row;
pub mod token_row;

pub use self::mint_row::*;
pub use self::multisig_row::*;
pub use self::token_row::*;

use super::Token2022Account;

pub struct Token2022AccountsMigration;

impl sqlx_migrator::Migration<sqlx::Postgres> for Token2022AccountsMigration {
    fn app(&self) -> &str {
        "token-2022"
    }

    fn name(&self) -> &str {
        "token_2022_accounts"
    }

    fn operations(&self) -> Vec<Box<dyn sqlx_migrator::Operation<sqlx::Postgres>>> {
        vec![
            Box::new(MintMigrationOperation),
            Box::new(MultisigMigrationOperation),
            Box::new(TokenMigrationOperation),
        ]
    }

    fn parents(&self) -> Vec<Box<dyn sqlx_migrator::Migration<sqlx::Postgres>>> {
        vec![]
    }
}

pub struct Token2022AccountWithMetadata(
    pub Token2022Account,
    pub carbon_core::account::AccountMetadata,
);

impl From<(Token2022Account, carbon_core::account::AccountMetadata)>
    for Token2022AccountWithMetadata
{
    fn from(value: (Token2022Account, carbon_core::account::AccountMetadata)) -> Self {
        Token2022AccountWithMetadata(value.0, value.1)
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::Insert for Token2022AccountWithMetadata {
    async fn insert(&self, pool: &sqlx::PgPool) -> carbon_core::error::CarbonResult<()> {
        let Token2022AccountWithMetadata(account, metadata) = self;

        match account {
            Token2022Account::Mint(account) => {
                let row = mint_row::MintRow::from_parts(*account.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
            Token2022Account::Token(account) => {
                let row = token_row::TokenRow::from_parts(*account.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
            Token2022Account::Multisig(account) => {
                let row = multisig_row::MultisigRow::from_parts(*account.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
        }
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::Upsert for Token2022AccountWithMetadata {
    async fn upsert(&self, pool: &sqlx::PgPool) -> carbon_core::error::CarbonResult<()> {
        let Token2022AccountWithMetadata(account, metadata) = self;
        match account {
            Token2022Account::Mint(account) => {
                let row = mint_row::MintRow::from_parts(*account.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
            Token2022Account::Token(account) => {
                let row = token_row::TokenRow::from_parts(*account.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
            Token2022Account::Multisig(account) => {
                let row = multisig_row::MultisigRow::from_parts(*account.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
        }
    }
}
