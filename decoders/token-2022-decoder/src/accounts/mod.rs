//! This code was AUTOGENERATED using the Codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun Codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use solana_program_pack::Pack;
use spl_token_2022::extension::StateWithExtensions;

use crate::Token2022Decoder;
use crate::PROGRAM_ID;

#[cfg(feature = "postgres")]
pub mod postgres;

#[cfg(feature = "graphql")]
pub mod graphql;

pub mod mint;
pub mod multisig;
pub mod token;

#[derive(Debug, Clone, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[cfg_attr(feature = "serde", serde(tag = "type", content = "data"))]
pub enum Token2022Account {
    Mint(Box<mint::Mint>),
    Multisig(Box<multisig::Multisig>),
    Token(Box<token::Token>),
}

impl<'a> carbon_core::account::AccountDecoder<'a> for Token2022Decoder {
    type AccountType = Token2022Account;

    fn decode_account(
        &self,
        account: &'a solana_account::Account,
    ) -> Option<carbon_core::account::DecodedAccount<Self::AccountType>> {
        if account.owner != PROGRAM_ID {
            return None;
        }

        if let Ok(data) = StateWithExtensions::<spl_token_2022::state::Mint>::unpack(&account.data)
        {
            return Some(carbon_core::account::DecodedAccount {
                lamports: account.lamports,
                data: Token2022Account::Mint(Box::new(mint::Mint::from(data))),
                owner: account.owner,
                executable: account.executable,
                rent_epoch: account.rent_epoch,
            });
        }

        if let Ok(data) =
            StateWithExtensions::<spl_token_2022::state::Account>::unpack(&account.data)
        {
            return Some(carbon_core::account::DecodedAccount {
                lamports: account.lamports,
                data: Token2022Account::Token(Box::new(token::Token::from(data))),
                owner: account.owner,
                executable: account.executable,
                rent_epoch: account.rent_epoch,
            });
        }

        if let Ok(data) = spl_token_2022::state::Multisig::unpack_from_slice(&account.data) {
            return Some(carbon_core::account::DecodedAccount {
                lamports: account.lamports,
                data: Token2022Account::Multisig(Box::new(multisig::Multisig::from(data))),
                owner: account.owner,
                executable: account.executable,
                rent_epoch: account.rent_epoch,
            });
        }

        None
    }
}
