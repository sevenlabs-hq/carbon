//! This code was AUTOGENERATED using the Codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun Codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!
use carbon_core::CarbonDeserialize;
use carbon_core::borsh;
use carbon_core::deserialize::CarbonDeserialize;
use crate::types::AccountState;
use crate::types::Extension;
use solana_pubkey::Pubkey;

#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[derive(Debug, Clone, borsh::BorshSerialize, CarbonDeserialize, PartialEq)]
pub struct Token {
    /// The mint associated with this account.
    pub mint: Pubkey,
    /// The owner of this account.
    pub owner: Pubkey,
    /// The amount of tokens this account holds.
    pub amount: u64,
    /// If `delegate` is `Some` then `delegated_amount` represents
    /// the amount authorized by the delegate.
    pub delegate: Option<Pubkey>,
    /// The account's state.
    pub state: AccountState,
    /// If is_native.is_some, this is a native token, and the value logs the
    /// rent-exempt reserve. An Account is required to be rent-exempt, so
    /// the value is used by the Processor to ensure that wrapped SOL
    /// accounts do not drop below this threshold.
    pub is_native: Option<u64>,
    /// The amount delegated.
    pub delegated_amount: u64,
    /// Optional authority to close the account.
    pub close_authority: Option<Pubkey>,
    /// The extensions activated on the token account.
    pub extensions: Option<Vec<Extension>>,
}

impl Token {
    pub fn decode(data: &[u8]) -> Option<Self> {
        if data.len() != 165 {
            return None;
        }

        let data_slice = data;

        let data_slice = &data_slice[0..];

        Self::deserialize(data_slice)
    }
}
