//! This code was AUTOGENERATED using the Codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun Codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!
use crate::types::AccountState;
use crate::types::Extension;
use carbon_core::borsh;
use carbon_core::deserialize::CarbonDeserialize;
use carbon_core::CarbonDeserialize;
use solana_pubkey::Pubkey;
use spl_token_2022::extension::BaseStateWithExtensions as _;
use spl_token_2022::extension::StateWithExtensions;

#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[derive(Debug, Clone, borsh::BorshSerialize, CarbonDeserialize, PartialEq)]
pub struct Token {
    /// The mint associated with this account.
    pub mint: Pubkey,
    /// The owner of this account.
    pub owner: Pubkey,
    /// The amount of tokens this account holds.
    pub amount: u64,
    /// If `delegate` is `Some` then `delegated_amount` represents
    /// the amount authorized by the delegate.
    pub delegate: Option<Pubkey>,
    /// The account's state.
    pub state: AccountState,
    /// If is_native.is_some, this is a native token, and the value logs the
    /// rent-exempt reserve. An Account is required to be rent-exempt, so
    /// the value is used by the Processor to ensure that wrapped SOL
    /// accounts do not drop below this threshold.
    pub is_native: Option<u64>,
    /// The amount delegated.
    pub delegated_amount: u64,
    /// Optional authority to close the account.
    pub close_authority: Option<Pubkey>,
    /// The extensions activated on the token account.
    pub extensions: Option<Vec<Extension>>,
}

impl Token {
    pub fn decode(data: &[u8]) -> Option<Self> {
        let data_slice = data;

        let data_slice = &data_slice[0..];

        Self::deserialize(data_slice)
    }
}

impl From<StateWithExtensions<'_, spl_token_2022::state::Account>> for Token {
    fn from(value: StateWithExtensions<'_, spl_token_2022::state::Account>) -> Self {
        let extensions = value.get_extension_types().ok().map(|extensions| {
            extensions
                .iter()
                .filter_map(|extension_type| {
                    Extension::from_account_and_type(&value, extension_type)
                })
                .collect::<Vec<_>>()
        });

        Token {
            mint: value.base.mint,
            owner: value.base.owner,
            amount: value.base.amount,
            delegate: value.base.delegate.into(),
            state: match value.base.state {
                spl_token_2022::state::AccountState::Uninitialized => AccountState::Uninitialized,
                spl_token_2022::state::AccountState::Initialized => AccountState::Initialized,
                spl_token_2022::state::AccountState::Frozen => AccountState::Frozen,
            },
            is_native: value.base.is_native.into(),
            delegated_amount: value.base.delegated_amount,
            close_authority: value.base.close_authority.into(),
            extensions,
        }
    }
}
