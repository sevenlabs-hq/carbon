//! This code was AUTOGENERATED using the Codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun Codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!
use crate::types::AccountState;
use crate::types::DecryptableBalance;
use crate::types::EncryptedBalance;
use crate::types::TransferFee;
use carbon_core::borsh;
use solana_pubkey::Pubkey;
use spl_pod::primitives::PodI64;
use spl_token_2022::extension::BaseStateWithExtensions as _;
use spl_token_2022::extension::ExtensionType;
use spl_token_2022::extension::StateWithExtensions;
use spl_token_2022::solana_zk_sdk;
use spl_token_2022::solana_zk_sdk::encryption::elgamal::ElGamalPubkey;
use spl_token_2022::solana_zk_sdk::encryption::pod::elgamal::PodElGamalPubkey;
use spl_type_length_value::variable_len_pack::VariableLenPack;
use std::collections::HashMap;

#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[derive(Debug, Clone, borsh::BorshSerialize, borsh::BorshDeserialize, PartialEq)]
pub enum Extension {
    Uninitialized,
    TransferFeeConfig {
        /// Optional authority to set the fee.
        transfer_fee_config_authority: Pubkey,
        /// Withdraw from mint instructions must be signed by this key.
        withdraw_withheld_authority: Pubkey,
        /// Withheld transfer fee tokens that have been moved to the mint for withdrawal.
        withheld_amount: u64,
        /// Older transfer fee, used if the current epoch < newerTransferFee.epoch.
        older_transfer_fee: TransferFee,
        /// Newer transfer fee, used if the current epoch >= newerTransferFee.epoch.
        newer_transfer_fee: TransferFee,
    },
    TransferFeeAmount {
        /// Withheld transfer fee tokens that can be claimed by the fee authority.
        withheld_amount: u64,
    },
    MintCloseAuthority {
        close_authority: Pubkey,
    },
    ConfidentialTransferMint {
        /// Authority to modify the `ConfidentialTransferMint` configuration and to
        /// approve new accounts (if `auto_approve_new_accounts` is true).
        ///
        /// The legacy Token Multisig account is not supported as the authority.
        authority: Option<Pubkey>,
        /// Indicate if newly configured accounts must be approved by the
        /// `authority` before they may be used by the user.
        ///
        /// * If `true`, no approval is required and new accounts may be used immediately.
        /// * If `false`, the authority must approve newly configured accounts (see
        ///   `ConfidentialTransferInstruction::ConfigureAccount`).
        auto_approve_new_accounts: bool,
        /// Authority to decode any transfer amount in a confidential transfer.
        auditor_elgamal_pubkey: Option<Pubkey>,
    },
    ConfidentialTransferAccount {
        /// `true` if this account has been approved for use. All confidential
        /// transfer operations for the account will fail until approval is granted.
        approved: bool,
        /// The public key associated with ElGamal encryption.
        elgamal_pubkey: Pubkey,
        /// The low 16 bits of the pending balance (encrypted by `elgamal_pubkey`).
        pending_balance_low: EncryptedBalance,
        /// The high 32 bits of the pending balance (encrypted by `elgamal_pubkey`).
        pending_balance_high: EncryptedBalance,
        /// The available balance (encrypted by `encrypiton_pubkey`).
        available_balance: EncryptedBalance,
        /// The decryptable available balance.
        decryptable_available_balance: DecryptableBalance,
        /// If `false`, the extended account rejects any incoming confidential transfers.
        allow_confidential_credits: bool,
        /// If `false`, the base account rejects any incoming transfers.
        allow_non_confidential_credits: bool,
        /// The total number of `Deposit` and `Transfer` instructions that have credited `pending_balance`.
        pending_balance_credit_counter: u64,
        /// The maximum number of `Deposit` and `Transfer` instructions that can
        /// credit `pending_balance` before the `ApplyPendingBalance`
        /// instruction is executed.
        maximum_pending_balance_credit_counter: u64,
        /// The `expected_pending_balance_credit_counter` value that was included in
        /// the last `ApplyPendingBalance` instruction.
        expected_pending_balance_credit_counter: u64,
        /// The actual `pending_balance_credit_counter` when the last
        /// `ApplyPendingBalance` instruction was executed.
        actual_pending_balance_credit_counter: u64,
    },
    DefaultAccountState {
        state: AccountState,
    },
    ImmutableOwner {},
    MemoTransfer {
        /// Require transfers into this account to be accompanied by a memo.
        require_incoming_transfer_memos: bool,
    },
    NonTransferable {},
    InterestBearingConfig {
        rate_authority: Pubkey,
        initialization_timestamp: u64,
        pre_update_average_rate: i16,
        last_update_timestamp: u64,
        current_rate: i16,
    },
    CpiGuard {
        /// Lock certain token operations from taking place within CPI for this account.
        lock_cpi: bool,
    },
    PermanentDelegate {
        delegate: Pubkey,
    },
    NonTransferableAccount {},
    TransferHook {
        /// The transfer hook update authority.
        authority: Pubkey,
        /// The transfer hook program account.
        program_id: Pubkey,
    },
    TransferHookAccount {
        /// Whether or not this account is currently transferring tokens
        /// True during the transfer hook cpi, otherwise false.
        transferring: bool,
    },
    ConfidentialTransferFee {
        /// Optional authority to set the withdraw withheld authority ElGamal key.
        authority: Option<Pubkey>,
        /// Withheld fees from accounts must be encrypted with this ElGamal key.
        ///
        /// Note that whoever holds the ElGamal private key for this ElGamal public
        /// key has the ability to decode any withheld fee amount that are
        /// associated with accounts. When combined with the fee parameters, the
        /// withheld fee amounts can reveal information about transfer amounts.
        elgamal_pubkey: Pubkey,
        /// If `false`, the harvest of withheld tokens to mint is rejected.
        harvest_to_mint_enabled: bool,
        /// Withheld confidential transfer fee tokens that have been moved to the
        /// mint for withdrawal.
        withheld_amount: EncryptedBalance,
    },
    ConfidentialTransferFeeAmount {
        /// Amount withheld during confidential transfers, to be harvest to the mint.
        withheld_amount: EncryptedBalance,
    },
    MetadataPointer {
        /// Optional authority that can set the metadata address.
        authority: Option<Pubkey>,
        /// Optional Account Address that holds the metadata.
        metadata_address: Option<Pubkey>,
    },
    TokenMetadata {
        /// The authority that can sign to update the metadata.
        update_authority: Option<Pubkey>,
        /// The associated mint, used to counter spoofing to be sure that metadata belongs to a particular mint.
        mint: Pubkey,
        /// The longer name of the token.
        name: String,
        /// The shortened symbol for the token.
        symbol: String,
        /// The URI pointing to richer metadata.
        uri: String,
        /// Any additional metadata about the token as key-value pairs.
        additional_metadata: HashMap<String, String>,
    },
    GroupPointer {
        /// Optional authority that can set the group address.
        authority: Option<Pubkey>,
        /// Optional account address that holds the group.
        group_address: Option<Pubkey>,
    },
    TokenGroup {
        /// The authority that can sign to update the group.
        update_authority: Option<Pubkey>,
        /// The associated mint, used to counter spoofing to be sure that group belongs to a particular mint.
        mint: Pubkey,
        /// The current number of group members.
        size: u64,
        /// The maximum number of group members.
        max_size: u64,
    },
    GroupMemberPointer {
        /// Optional authority that can set the member address.
        authority: Option<Pubkey>,
        /// Optional account address that holds the member.
        member_address: Option<Pubkey>,
    },
    TokenGroupMember {
        /// The associated mint, used to counter spoofing to be sure that member belongs to a particular mint.
        mint: Pubkey,
        /// The pubkey of the `TokenGroup`.
        group: Pubkey,
        /// The member number.
        member_number: u64,
    },
    ConfidentialMintBurn,
    ScaledUiAmountConfig {
        authority: Pubkey,
        multiplier: f64,
        new_multiplier_effective_timestamp: u64,
        new_multiplier: f64,
    },
    PausableConfig {
        authority: Option<Pubkey>,
        paused: bool,
    },
    PausableAccount,
}

impl Extension {
    pub fn from_mint_and_type(
        state_with_extensions: &StateWithExtensions<'_, spl_token_2022::state::Mint>,
        extension_type: &spl_token_2022::extension::ExtensionType,
    ) -> Option<Self> {
        match extension_type {
            ExtensionType::Uninitialized => None,
            ExtensionType::TransferFeeConfig => {
                state_with_extensions.get_extension::<spl_token_2022::extension::transfer_fee::TransferFeeConfig>().map(|extension| Extension::TransferFeeConfig {
                        transfer_fee_config_authority: extension.transfer_fee_config_authority.0,
                        withdraw_withheld_authority: extension.withdraw_withheld_authority.0,
                        withheld_amount: extension.withheld_amount.into(),
                        older_transfer_fee: TransferFee {
                            epoch: extension.older_transfer_fee.epoch.into(),
                            maximum_fee: extension.older_transfer_fee.maximum_fee.into(),
                            transfer_fee_basis_points: extension.older_transfer_fee.transfer_fee_basis_points.into(),
                        },
                        newer_transfer_fee: TransferFee {
                            epoch: extension.newer_transfer_fee.epoch.into(),
                            maximum_fee: extension.newer_transfer_fee.maximum_fee.into(),
                            transfer_fee_basis_points: extension.newer_transfer_fee.transfer_fee_basis_points.into(),
                        },
                    }).ok()
            }
            ExtensionType::MintCloseAuthority => {
                state_with_extensions.get_extension::<spl_token_2022::extension::mint_close_authority::MintCloseAuthority>().map(|extension| Extension::MintCloseAuthority {
                    close_authority: extension.close_authority.0,
                }).ok()
            }
            ExtensionType::ConfidentialTransferMint => {
                state_with_extensions.get_extension::<spl_token_2022::extension::confidential_transfer::ConfidentialTransferMint>().map(|extension| Some(Extension::ConfidentialTransferMint {
                    authority: extension.authority.into(),
                    auto_approve_new_accounts: extension.auto_approve_new_accounts.into(),
                    auditor_elgamal_pubkey: Option::<PodElGamalPubkey>::from(extension.auditor_elgamal_pubkey).and_then(|pubkey| Some(Pubkey::new_from_array(ElGamalPubkey::try_from(pubkey).ok()?.into()))),
                })).ok().flatten()
            }
            ExtensionType::DefaultAccountState => {
                state_with_extensions.get_extension::<spl_token_2022::extension::default_account_state::DefaultAccountState>().map(|extension| Some(Extension::DefaultAccountState {
                    state: match extension.state {
                        0 => AccountState::Uninitialized,
                        1 => AccountState::Initialized,
                        2 => AccountState::Frozen,
                        _ => return None,
                    }
                })).ok().flatten()
            }
            ExtensionType::NonTransferable => {
                state_with_extensions.get_extension::<spl_token_2022::extension::non_transferable::NonTransferable>().map(|_extension| Extension::NonTransferable {}).ok()
            }
            ExtensionType::InterestBearingConfig => {
                state_with_extensions.get_extension::<spl_token_2022::extension::interest_bearing_mint::InterestBearingConfig>().map(|extension| Extension::InterestBearingConfig {
                    rate_authority: extension.rate_authority.0,
                    initialization_timestamp: unsafe { std::mem::transmute::<PodI64, u64>(extension.initialization_timestamp) },
                    pre_update_average_rate: extension.pre_update_average_rate.into(),
                    last_update_timestamp: unsafe { std::mem::transmute::<PodI64, u64>(extension.last_update_timestamp) },
                    current_rate: extension.current_rate.into(),
                }).ok()
            }
            ExtensionType::PermanentDelegate => {
                state_with_extensions.get_extension::<spl_token_2022::extension::permanent_delegate::PermanentDelegate>().map(|extension| Extension::PermanentDelegate {
                    delegate: extension.delegate.0,
                }).ok()
            }
            ExtensionType::TransferHook => {
                state_with_extensions.get_extension::<spl_token_2022::extension::transfer_hook::TransferHook>().map(|extension| Extension::TransferHook {
                    authority: extension.authority.0,
                    program_id: extension.program_id.0,
                }).ok()
            }
            ExtensionType::ConfidentialTransferFeeConfig => {
                state_with_extensions.get_extension::<spl_token_2022::extension::confidential_transfer_fee::ConfidentialTransferFeeConfig>().map(|extension| Some(Extension::ConfidentialTransferFee {
                        authority: extension.authority.into(),
                        harvest_to_mint_enabled: extension.harvest_to_mint_enabled.into(),
                        elgamal_pubkey: Pubkey::new_from_array(ElGamalPubkey::try_from(extension.withdraw_withheld_authority_elgamal_pubkey).ok()?.into()),
                        withheld_amount: EncryptedBalance(solana_zk_sdk::encryption::elgamal::ElGamalCiphertext::try_from(extension.withheld_amount).ok()?.to_bytes()),
                })).ok().flatten()
            }
            ExtensionType::MetadataPointer => {
                state_with_extensions.get_extension::<spl_token_2022::extension::metadata_pointer::MetadataPointer>().map(|extension| Extension::MetadataPointer {
                        authority: extension.authority.into(),
                        metadata_address: extension.metadata_address.into(),
                    }).ok()
            }
            ExtensionType::TokenMetadata => {
                state_with_extensions.get_extension_bytes::<spl_token_metadata_interface::state::TokenMetadata>().map(|extension| spl_token_metadata_interface::state::TokenMetadata::unpack_from_slice(extension).ok().map(|extension| Extension::TokenMetadata {
                        update_authority: extension.update_authority.into(),
                        mint: extension.mint,
                        name: extension.name,
                        symbol: extension.symbol,
                        uri: extension.uri,
                        additional_metadata: extension.additional_metadata.iter().map(|(key, value)| (key.clone(), value.clone())).collect(),
                    })).ok().flatten()
            },
            ExtensionType::GroupPointer => {
                state_with_extensions.get_extension::<spl_token_2022::extension::group_pointer::GroupPointer>().map(|extension| Extension::GroupPointer {
                    authority: extension.authority.into(),
                    group_address: extension.group_address.into(),
                }).ok()
            }
            ExtensionType::TokenGroup => {
                state_with_extensions.get_extension_bytes::<spl_token_group_interface::state::TokenGroup>().map(|extension| spl_pod::bytemuck::pod_from_bytes::<spl_token_group_interface::state::TokenGroup>(extension).ok().map(|extension| Extension::TokenGroup {
                        update_authority: extension.update_authority.into(),
                        mint: extension.mint,
                        size: extension.size.into(),
                        max_size: extension.max_size.into(),
                    })).ok().flatten()
            },
            ExtensionType::GroupMemberPointer => {
                state_with_extensions.get_extension::<spl_token_2022::extension::group_member_pointer::GroupMemberPointer>().map(|extension| Extension::GroupMemberPointer {
                    authority: extension.authority.into(),
                    member_address: extension.member_address.into(),
                }).ok()
            }
            ExtensionType::ConfidentialMintBurn => {
                state_with_extensions.get_extension::<spl_token_2022::extension::confidential_mint_burn::ConfidentialMintBurn>().map(|_extension| Extension::ConfidentialMintBurn).ok()
            }
            ExtensionType::TokenGroupMember => {
                state_with_extensions.get_extension_bytes::<spl_token_group_interface::state::TokenGroupMember>().map(|extension| spl_pod::bytemuck::pod_from_bytes::<spl_token_group_interface::state::TokenGroupMember>(extension).ok().map(|extension| Extension::TokenGroupMember {
                        mint: extension.mint,
                        group: extension.group,
                        member_number: extension.member_number.into(),
                    })).ok().flatten()
            },
            ExtensionType::ScaledUiAmount => {
                state_with_extensions.get_extension::<spl_token_2022::extension::scaled_ui_amount::ScaledUiAmountConfig>().map(|extension| Extension::ScaledUiAmountConfig {
                        authority: extension.authority.0,
                        multiplier: extension.multiplier.into(),
                        new_multiplier_effective_timestamp: u64::from_le_bytes(unsafe { std::mem::transmute::<PodI64, [u8; 8]>(extension.new_multiplier_effective_timestamp)}),
                        new_multiplier: extension.new_multiplier.into(),
                    }).ok()
            }
            ExtensionType::Pausable => {
                state_with_extensions.get_extension::<spl_token_2022::extension::pausable::PausableConfig>().map(|extension| Extension::PausableConfig {
                    authority: extension.authority.into(),
                    paused: extension.paused.into(),
                }).ok()
            }
            _ => None,
        }
    }

    pub fn from_account_and_type(
        state_with_extensions: &StateWithExtensions<'_, spl_token_2022::state::Account>,
        extension_type: &spl_token_2022::extension::ExtensionType,
    ) -> Option<Self> {
        match extension_type {
            ExtensionType::TransferFeeAmount => {
                state_with_extensions.get_extension::<spl_token_2022::extension::transfer_fee::TransferFeeAmount>().map(|extension| Extension::TransferFeeAmount {
                        withheld_amount: extension.withheld_amount.into(),
                    }).ok()
            }
            ExtensionType::ConfidentialTransferAccount => {
                state_with_extensions.get_extension::<spl_token_2022::extension::confidential_transfer::ConfidentialTransferAccount>().map(|extension| Some(Extension::ConfidentialTransferAccount {
                    approved: extension.approved.into(),
                    elgamal_pubkey: Pubkey::new_from_array(ElGamalPubkey::try_from(extension.elgamal_pubkey).ok()?.into()),
                    pending_balance_low: EncryptedBalance(solana_zk_sdk::encryption::elgamal::ElGamalCiphertext::try_from(extension.pending_balance_lo).ok()?.to_bytes()),
                    pending_balance_high: EncryptedBalance(solana_zk_sdk::encryption::elgamal::ElGamalCiphertext::try_from(extension.pending_balance_hi).ok()?.to_bytes()),
                    available_balance: EncryptedBalance(solana_zk_sdk::encryption::elgamal::ElGamalCiphertext::try_from(extension.available_balance).ok()?.to_bytes()),
                    decryptable_available_balance: DecryptableBalance(solana_zk_sdk::encryption::auth_encryption::AeCiphertext::try_from(extension.decryptable_available_balance).ok()?.to_bytes()),
                    allow_confidential_credits: extension.allow_confidential_credits.into(),
                    allow_non_confidential_credits: extension.allow_non_confidential_credits.into(),
                    pending_balance_credit_counter: extension.pending_balance_credit_counter.into(),
                    maximum_pending_balance_credit_counter: extension.maximum_pending_balance_credit_counter.into(),
                    expected_pending_balance_credit_counter: extension.expected_pending_balance_credit_counter.into(),
                    actual_pending_balance_credit_counter: extension.actual_pending_balance_credit_counter.into(),
                })).ok().flatten()
            }
            ExtensionType::MemoTransfer => {
                state_with_extensions.get_extension::<spl_token_2022::extension::memo_transfer::MemoTransfer>().map(|extension| Extension::MemoTransfer {
                    require_incoming_transfer_memos: extension.require_incoming_transfer_memos.into()
                }).ok()
            }
            ExtensionType::NonTransferableAccount => {
                state_with_extensions.get_extension::<spl_token_2022::extension::non_transferable::NonTransferableAccount>().map(|_extension| Extension::NonTransferableAccount {}).ok()
            }
            ExtensionType::TransferHookAccount => {
                state_with_extensions.get_extension::<spl_token_2022::extension::transfer_hook::TransferHookAccount>().map(|extension| Extension::TransferHookAccount {
                    transferring: extension.transferring.into(),
                }).ok()
            }
            ExtensionType::CpiGuard => {
                    state_with_extensions.get_extension::<spl_token_2022::extension::cpi_guard::CpiGuard>().map(|extension| Extension::CpiGuard {
                    lock_cpi: extension.lock_cpi.into(),
                }).ok()
            }
            ExtensionType::ConfidentialTransferFeeAmount => {
                state_with_extensions.get_extension::<spl_token_2022::extension::confidential_transfer_fee::ConfidentialTransferFeeAmount>().map(|extension| Some(Extension::ConfidentialTransferFeeAmount {
                    withheld_amount: EncryptedBalance(solana_zk_sdk::encryption::elgamal::ElGamalCiphertext::try_from(extension.withheld_amount).ok()?.to_bytes()),
                })).ok().flatten()
            }
            ExtensionType::PausableAccount => {
                state_with_extensions.get_extension::<spl_token_2022::extension::pausable::PausableAccount>().map(|_extension| Extension::PausableAccount).ok()
            }
            _ => None,
        }
    }
}
